<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>albow.core.ui.RootWidget API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>albow.core.ui.RootWidget</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">from typing import List
from typing import cast

import sys

from time import sleep

import logging
from logging import Logger


import pygame
from pygame.mouse import set_visible as set_mouse_visible
from pygame.time import set_timer as set_pygame_timer

from pygame import Surface

from pygame.event import Event
from pygame.event import get_grab
from pygame.event import set_grab

from pygame.locals import USEREVENT
from pygame.locals import OPENGL

from albow.core.ui.Widget import Widget

from albow.core.Scheduler import Scheduler
from albow.core.CoreUtilities import CoreUtilities
from albow.core.exceptions.CancelException import CancelException
from albow.core.exceptions.ApplicationException import ApplicationException

from albow.core.UserEventCall import UserEventCall

from albow.media.MusicUtilities import MusicUtilities


class RootWidget(Widget):

    &#34;&#34;&#34;
    For the GUI to function, there must be exactly one instance of RootWidget. It implements the main event loop
    and serves as the ultimate container for all other visible widgets.

    The root widget can be found using the `RootWidget.get_root()`

    &#34;&#34;&#34;
    root_widget = None
    &#34;&#34;&#34;
    Root of the containment hierarchy
    &#34;&#34;&#34;
    top_widget = None
    &#34;&#34;&#34;
    Initial dispatch target
    &#34;&#34;&#34;
    clicked_widget = None
    &#34;&#34;&#34;
    Target of mouse_drag and mouse_up events
    &#34;&#34;&#34;

    # redraw_every_frame = False
    # &#34;&#34;&#34;
    # If true, all widgets will be redrawn on every animation frame (i.e. after every call to begin_frame()). If false,
    # redrawing only occurs after user input events, such as mouse clicks and keystrokes, or if a widget calls
    # its invalidate() method. The default is false.
    # &#34;&#34;&#34;
    last_mouse_event_handler = None

    ourTimerEvent = None
    &#34;&#34;&#34;
    Timer event pending delivery
    &#34;&#34;&#34;
    nextFrameDue = 0.0

    do_draw          = False
    _is_gl_container = True
    frame_time       = 0.0
    _use_sleep       = True

    last_mouse_event: Event = Event(0, {&#39;pos&#39;: (0, 0), &#39;local&#39;: (0, 0)})

    classLogger: Logger
    userEventCallList: List = []

    def __init__(self, surface: Surface, **kwds):
        &#34;&#34;&#34;
        Initializes the root widget with the given surface, which will normally be the PyGame screen,
        but could be a subsurface of it.

        Args:
            surface:  A Pygame surface

            **kwds:
        &#34;&#34;&#34;
        super().__init__(surface.get_rect(), **kwds)

        RootWidget.classLogger = logging.getLogger(__name__)
        CoreUtilities.init_timebase()
        self.surface = surface
        RootWidget.root_widget = self
        Widget.root_widget = self

        self.is_gl = surface.get_flags() &amp; OPENGL != 0
        # RootWidget.classLogger.info(f&#34;self.is_gl: {self.is_gl}&#34;)
        if self.is_gl:

            from albow.openGL.GLSurface import GLSurface
            self.gl_surface = GLSurface(surface, self.rect)

    def set_timer(self, ms):
        &#34;&#34;&#34;
        Arranges for timer events to be generated every interval milliseconds. See timer_event().

        Args:
            ms:  The timer interval in milli-seconds

        &#34;&#34;&#34;
        self.frame_time = ms
        if not self._use_sleep:
            set_pygame_timer(USEREVENT, max(1, int(round(ms))))

    def run(self):
        &#34;&#34;&#34;
        Runs the main event loop. Control is retained until a QUIT event is received, whereupon the quit() method
        is called.

        &#34;&#34;&#34;
        self.run_modal(cast(Widget, None))

    def run_modal(self, modal_widget: Widget):
        &#34;&#34;&#34;
            Runs a modal event loop. The widget is run as a modal dialog until its dismiss() method is called.
        Args:
            modal_widget:  The modal widget
        &#34;&#34;&#34;
        is_modal = modal_widget is not None
        modal_widget = modal_widget or self
        relative_pause = False
        relative_warmup = 0

        was_modal = None
        try:
            RootWidget.old_top_widget = RootWidget.top_widget
            RootWidget.top_widget = modal_widget
            was_modal = modal_widget.is_modal
            modal_widget.is_modal = True

            modal_widget.modal_result = None
            if not modal_widget.focus_switch:
                modal_widget.tab_to_first()

            self.do_draw = True
            use_sleep = self._use_sleep

            from albow.core.ui.AlbowEventLoop import AlbowEventLoop
            from albow.core.ui.EventLoopParams import EventLoopParams

            eventLoop: AlbowEventLoop = AlbowEventLoop(modalWidget=modal_widget, containingWidget=self)

            last_click_time = 0
            num_clicks = 0
            while modal_widget.modal_result is None:

                defer_drawing = self.frame_time != 0.0 and modal_widget.defer_drawing()
                try:
                    if not is_modal:
                        if RootWidget.ourTimerEvent:
                            if not use_sleep and defer_drawing:
                                Scheduler.make_scheduled_calls()
                            CoreUtilities.add_modifiers(RootWidget.ourTimerEvent)
                            if RootWidget.last_mouse_event:
                                RootWidget.ourTimerEvent.dict[&#39;pos&#39;] = RootWidget.last_mouse_event.pos
                                RootWidget.ourTimerEvent.dict[&#39;local&#39;] = RootWidget.last_mouse_event.local
                            if RootWidget.last_mouse_event_handler:
                                RootWidget.last_mouse_event_handler.setup_cursor(RootWidget.ourTimerEvent)
                            self.do_draw = self.timer_event(RootWidget.ourTimerEvent)
                            RootWidget.ourTimerEvent = None
                        else:
                            if defer_drawing:
                                self.do_draw = False
                    # RootWidget.classLogger.info(f&#34;self.do_draw: {self.do_draw}&#34;)
                    if self.do_draw:
                        if self.is_gl:
                            gl_surface = self.gl_surface
                            gl_surface.gl_clear(self.bg_color)
                            self.gl_draw_all(gl_surface)
                            gl_surface.gl_flush()
                        else:
                            self.draw_all(self.surface)
                        self.do_draw = False
                        # tb1 = timestamp() ###
                        pygame.display.flip()

                    in_relative_mode = bool(modal_widget.relative_mode())
                    grab = in_relative_mode and not relative_pause
                    if grab != get_grab():
                        set_grab(grab)
                        set_mouse_visible(not grab)
                        relative_warmup = 3            # Ignore spurious deltas on entering relative mode
                    if use_sleep and defer_drawing:

                        time_now = Scheduler.timestamp()

                        if RootWidget.nextFrameDue &lt; time_now:
                            RootWidget.nextFrameDue = time_now

                        while True:
                            sleep_time = Scheduler.make_due_calls(time_now, RootWidget.nextFrameDue)
                            if sleep_time &lt;= 0.0:
                                break

                            sleep(sleep_time / 1000.0)
                            time_now = Scheduler.timestamp()
                        RootWidget.nextFrameDue += self.frame_time
                        RootWidget.ourTimerEvent = Event(USEREVENT, {&#39;time&#39;: time_now})
                        events = []
                    else:
                        events = [pygame.event.wait()]
                    events.extend(pygame.event.get())

                    loopParams: EventLoopParams = EventLoopParams(use_sleep=use_sleep, relative_pause=relative_pause, do_draw=self.do_draw,
                                                                  relative_warmup=relative_warmup, last_click_time=last_click_time,
                                                                  num_clicks=num_clicks)

                    newParams: EventLoopParams = eventLoop.processEvents(eventList=events, relativeMode=in_relative_mode, deferDrawing=defer_drawing,
                                                                         eventLoopParams=loopParams)

                    use_sleep = newParams.use_sleep
                    relative_pause = newParams.relative_pause
                    self.do_draw = newParams.do_draw
                    relative_warmup = newParams.relative_warmup
                    last_click_time = newParams.last_click_time
                    num_clicks = newParams.num_clicks

                except CancelException:
                    pass

                except ApplicationException as e:
                    self.report_error(e)
        finally:
            modal_widget.is_modal = was_modal
            RootWidget.top_widget = RootWidget.old_top_widget

        RootWidget.clicked_widget = None

    def send_key(self, widget, name, event):
        CoreUtilities.add_modifiers(event)
        widget.dispatch_key(name, event)

    def begin_frame(self):
        &#34;&#34;&#34;Deprecated, use timer_event() instead.&#34;&#34;&#34;
        pass

    def has_focus(self):
        return True

    def quit(self):
        &#34;&#34;&#34;
        This method is called when a QUIT event is received. The default implementation first calls
        confirm_quit(), and if it returns true, calls sys.exit(0).
        &#34;&#34;&#34;
        if self.confirm_quit():
            sys.exit(0)

    def get_mouse_for(self, widget):
        last = RootWidget.last_mouse_event
        event = Event(0, last.dict)
        event.dict[&#39;local&#39;] = widget.global_to_local(event.pos)
        CoreUtilities.add_modifiers(event)
        return event

    def music_end(self):
        MusicUtilities.music_end()

    @staticmethod
    def getRoot():
        &#34;&#34;&#34;
        Returns:  The root widget of the containment hierarchy
        &#34;&#34;&#34;
        return RootWidget.root_widget

    @staticmethod
    def getTopWidget():
        return RootWidget.top_widget

    @staticmethod
    def getFocus():
        return RootWidget.top_widget.get_focus()

    @classmethod
    def addUserEvent(cls, newCallback: UserEventCall):

        cls.userEventCallList.append(newCallback)
        cls.classLogger.debug(f&#34;add - userEventListSize: {len(cls.userEventCallList)}&#34;)

    @classmethod
    def getUserEventList(cls):
        cls.classLogger.debug(f&#34;get - userEventListSize: {len(cls.userEventCallList)}&#34;)
        return cls.userEventCallList

    # ========================================================================
    #
    #  Abstract methods follow
    #
    # ========================================================================

    def report_error(self, e):
        pass

    def confirm_quit(self) -&gt; bool:
        &#34;&#34;&#34;
        Called to give an opportunity to ask the user to confirm quitting the main event loop. If it returns
        true, sys.exit(0) is performed, otherwise nothing is done. The default implementation unconditionally
        returns true.

        Returns: True to confirm else False

        &#34;&#34;&#34;
        return True

    def defer_drawing(self) -&gt; bool:
        &#34;&#34;&#34;
        f this method returns true, pending display updates are only performed when a timer event occurs and the
        timer_event() method of the root widget returns true. Otherwise, the display is updated after every input
        event except for mouse-move events. The default implementation returns True.

        Returns: True to defer else False

        &#34;&#34;&#34;
        return True

    def timer_event(self, event):
        &#34;&#34;&#34;
        Called when a timer event occurs. See set_timer(). If it returns true, a display update is performed. The
        default implementation returns true.

        Note:
            If multiple timer events occur during a single pass through the event loop, only the most recent
            one is passed to timer_event() and the others are discarded. Also, if other types of event occur during
            the same pass through the event loop, all the other events are processed before calling timer_event(), even
            if the timer event was not the last to occur chronologically.

        Args:
            event:

        Returns:  True

        &#34;&#34;&#34;
        self.begin_frame()
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="albow.core.ui.RootWidget.RootWidget"><code class="flex name class">
<span>class <span class="ident">RootWidget</span></span>
<span>(</span><span>surface, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>For the GUI to function, there must be exactly one instance of RootWidget. It implements the main event loop
and serves as the ultimate container for all other visible widgets.</p>
<p>The root widget can be found using the <a title="albow.core.ui.RootWidget.RootWidget.get_root" href="Widget.html#albow.core.ui.Widget.Widget.get_root"><code>Widget.get_root()</code></a></p>
<p>Initializes the root widget with the given surface, which will normally be the PyGame screen,
but could be a subsurface of it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>surface</code></strong></dt>
<dd>A Pygame surface</dd>
</dl>
<p>**kwds:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class RootWidget(Widget):

    &#34;&#34;&#34;
    For the GUI to function, there must be exactly one instance of RootWidget. It implements the main event loop
    and serves as the ultimate container for all other visible widgets.

    The root widget can be found using the `RootWidget.get_root()`

    &#34;&#34;&#34;
    root_widget = None
    &#34;&#34;&#34;
    Root of the containment hierarchy
    &#34;&#34;&#34;
    top_widget = None
    &#34;&#34;&#34;
    Initial dispatch target
    &#34;&#34;&#34;
    clicked_widget = None
    &#34;&#34;&#34;
    Target of mouse_drag and mouse_up events
    &#34;&#34;&#34;

    # redraw_every_frame = False
    # &#34;&#34;&#34;
    # If true, all widgets will be redrawn on every animation frame (i.e. after every call to begin_frame()). If false,
    # redrawing only occurs after user input events, such as mouse clicks and keystrokes, or if a widget calls
    # its invalidate() method. The default is false.
    # &#34;&#34;&#34;
    last_mouse_event_handler = None

    ourTimerEvent = None
    &#34;&#34;&#34;
    Timer event pending delivery
    &#34;&#34;&#34;
    nextFrameDue = 0.0

    do_draw          = False
    _is_gl_container = True
    frame_time       = 0.0
    _use_sleep       = True

    last_mouse_event: Event = Event(0, {&#39;pos&#39;: (0, 0), &#39;local&#39;: (0, 0)})

    classLogger: Logger
    userEventCallList: List = []

    def __init__(self, surface: Surface, **kwds):
        &#34;&#34;&#34;
        Initializes the root widget with the given surface, which will normally be the PyGame screen,
        but could be a subsurface of it.

        Args:
            surface:  A Pygame surface

            **kwds:
        &#34;&#34;&#34;
        super().__init__(surface.get_rect(), **kwds)

        RootWidget.classLogger = logging.getLogger(__name__)
        CoreUtilities.init_timebase()
        self.surface = surface
        RootWidget.root_widget = self
        Widget.root_widget = self

        self.is_gl = surface.get_flags() &amp; OPENGL != 0
        # RootWidget.classLogger.info(f&#34;self.is_gl: {self.is_gl}&#34;)
        if self.is_gl:

            from albow.openGL.GLSurface import GLSurface
            self.gl_surface = GLSurface(surface, self.rect)

    def set_timer(self, ms):
        &#34;&#34;&#34;
        Arranges for timer events to be generated every interval milliseconds. See timer_event().

        Args:
            ms:  The timer interval in milli-seconds

        &#34;&#34;&#34;
        self.frame_time = ms
        if not self._use_sleep:
            set_pygame_timer(USEREVENT, max(1, int(round(ms))))

    def run(self):
        &#34;&#34;&#34;
        Runs the main event loop. Control is retained until a QUIT event is received, whereupon the quit() method
        is called.

        &#34;&#34;&#34;
        self.run_modal(cast(Widget, None))

    def run_modal(self, modal_widget: Widget):
        &#34;&#34;&#34;
            Runs a modal event loop. The widget is run as a modal dialog until its dismiss() method is called.
        Args:
            modal_widget:  The modal widget
        &#34;&#34;&#34;
        is_modal = modal_widget is not None
        modal_widget = modal_widget or self
        relative_pause = False
        relative_warmup = 0

        was_modal = None
        try:
            RootWidget.old_top_widget = RootWidget.top_widget
            RootWidget.top_widget = modal_widget
            was_modal = modal_widget.is_modal
            modal_widget.is_modal = True

            modal_widget.modal_result = None
            if not modal_widget.focus_switch:
                modal_widget.tab_to_first()

            self.do_draw = True
            use_sleep = self._use_sleep

            from albow.core.ui.AlbowEventLoop import AlbowEventLoop
            from albow.core.ui.EventLoopParams import EventLoopParams

            eventLoop: AlbowEventLoop = AlbowEventLoop(modalWidget=modal_widget, containingWidget=self)

            last_click_time = 0
            num_clicks = 0
            while modal_widget.modal_result is None:

                defer_drawing = self.frame_time != 0.0 and modal_widget.defer_drawing()
                try:
                    if not is_modal:
                        if RootWidget.ourTimerEvent:
                            if not use_sleep and defer_drawing:
                                Scheduler.make_scheduled_calls()
                            CoreUtilities.add_modifiers(RootWidget.ourTimerEvent)
                            if RootWidget.last_mouse_event:
                                RootWidget.ourTimerEvent.dict[&#39;pos&#39;] = RootWidget.last_mouse_event.pos
                                RootWidget.ourTimerEvent.dict[&#39;local&#39;] = RootWidget.last_mouse_event.local
                            if RootWidget.last_mouse_event_handler:
                                RootWidget.last_mouse_event_handler.setup_cursor(RootWidget.ourTimerEvent)
                            self.do_draw = self.timer_event(RootWidget.ourTimerEvent)
                            RootWidget.ourTimerEvent = None
                        else:
                            if defer_drawing:
                                self.do_draw = False
                    # RootWidget.classLogger.info(f&#34;self.do_draw: {self.do_draw}&#34;)
                    if self.do_draw:
                        if self.is_gl:
                            gl_surface = self.gl_surface
                            gl_surface.gl_clear(self.bg_color)
                            self.gl_draw_all(gl_surface)
                            gl_surface.gl_flush()
                        else:
                            self.draw_all(self.surface)
                        self.do_draw = False
                        # tb1 = timestamp() ###
                        pygame.display.flip()

                    in_relative_mode = bool(modal_widget.relative_mode())
                    grab = in_relative_mode and not relative_pause
                    if grab != get_grab():
                        set_grab(grab)
                        set_mouse_visible(not grab)
                        relative_warmup = 3            # Ignore spurious deltas on entering relative mode
                    if use_sleep and defer_drawing:

                        time_now = Scheduler.timestamp()

                        if RootWidget.nextFrameDue &lt; time_now:
                            RootWidget.nextFrameDue = time_now

                        while True:
                            sleep_time = Scheduler.make_due_calls(time_now, RootWidget.nextFrameDue)
                            if sleep_time &lt;= 0.0:
                                break

                            sleep(sleep_time / 1000.0)
                            time_now = Scheduler.timestamp()
                        RootWidget.nextFrameDue += self.frame_time
                        RootWidget.ourTimerEvent = Event(USEREVENT, {&#39;time&#39;: time_now})
                        events = []
                    else:
                        events = [pygame.event.wait()]
                    events.extend(pygame.event.get())

                    loopParams: EventLoopParams = EventLoopParams(use_sleep=use_sleep, relative_pause=relative_pause, do_draw=self.do_draw,
                                                                  relative_warmup=relative_warmup, last_click_time=last_click_time,
                                                                  num_clicks=num_clicks)

                    newParams: EventLoopParams = eventLoop.processEvents(eventList=events, relativeMode=in_relative_mode, deferDrawing=defer_drawing,
                                                                         eventLoopParams=loopParams)

                    use_sleep = newParams.use_sleep
                    relative_pause = newParams.relative_pause
                    self.do_draw = newParams.do_draw
                    relative_warmup = newParams.relative_warmup
                    last_click_time = newParams.last_click_time
                    num_clicks = newParams.num_clicks

                except CancelException:
                    pass

                except ApplicationException as e:
                    self.report_error(e)
        finally:
            modal_widget.is_modal = was_modal
            RootWidget.top_widget = RootWidget.old_top_widget

        RootWidget.clicked_widget = None

    def send_key(self, widget, name, event):
        CoreUtilities.add_modifiers(event)
        widget.dispatch_key(name, event)

    def begin_frame(self):
        &#34;&#34;&#34;Deprecated, use timer_event() instead.&#34;&#34;&#34;
        pass

    def has_focus(self):
        return True

    def quit(self):
        &#34;&#34;&#34;
        This method is called when a QUIT event is received. The default implementation first calls
        confirm_quit(), and if it returns true, calls sys.exit(0).
        &#34;&#34;&#34;
        if self.confirm_quit():
            sys.exit(0)

    def get_mouse_for(self, widget):
        last = RootWidget.last_mouse_event
        event = Event(0, last.dict)
        event.dict[&#39;local&#39;] = widget.global_to_local(event.pos)
        CoreUtilities.add_modifiers(event)
        return event

    def music_end(self):
        MusicUtilities.music_end()

    @staticmethod
    def getRoot():
        &#34;&#34;&#34;
        Returns:  The root widget of the containment hierarchy
        &#34;&#34;&#34;
        return RootWidget.root_widget

    @staticmethod
    def getTopWidget():
        return RootWidget.top_widget

    @staticmethod
    def getFocus():
        return RootWidget.top_widget.get_focus()

    @classmethod
    def addUserEvent(cls, newCallback: UserEventCall):

        cls.userEventCallList.append(newCallback)
        cls.classLogger.debug(f&#34;add - userEventListSize: {len(cls.userEventCallList)}&#34;)

    @classmethod
    def getUserEventList(cls):
        cls.classLogger.debug(f&#34;get - userEventListSize: {len(cls.userEventCallList)}&#34;)
        return cls.userEventCallList

    # ========================================================================
    #
    #  Abstract methods follow
    #
    # ========================================================================

    def report_error(self, e):
        pass

    def confirm_quit(self) -&gt; bool:
        &#34;&#34;&#34;
        Called to give an opportunity to ask the user to confirm quitting the main event loop. If it returns
        true, sys.exit(0) is performed, otherwise nothing is done. The default implementation unconditionally
        returns true.

        Returns: True to confirm else False

        &#34;&#34;&#34;
        return True

    def defer_drawing(self) -&gt; bool:
        &#34;&#34;&#34;
        f this method returns true, pending display updates are only performed when a timer event occurs and the
        timer_event() method of the root widget returns true. Otherwise, the display is updated after every input
        event except for mouse-move events. The default implementation returns True.

        Returns: True to defer else False

        &#34;&#34;&#34;
        return True

    def timer_event(self, event):
        &#34;&#34;&#34;
        Called when a timer event occurs. See set_timer(). If it returns true, a display update is performed. The
        default implementation returns true.

        Note:
            If multiple timer events occur during a single pass through the event loop, only the most recent
            one is passed to timer_event() and the others are discarded. Also, if other types of event occur during
            the same pass through the event loop, all the other events are processed before calling timer_event(), even
            if the timer event was not the last to occur chronologically.

        Args:
            event:

        Returns:  True

        &#34;&#34;&#34;
        self.begin_frame()
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="albow.core.ui.Widget.Widget" href="Widget.html#albow.core.ui.Widget.Widget">Widget</a></li>
<li><a title="albow.core.ui.AlbowRect.AlbowRect" href="AlbowRect.html#albow.core.ui.AlbowRect.AlbowRect">AlbowRect</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="albow.core.ui.Shell.Shell" href="Shell.html#albow.core.ui.Shell.Shell">Shell</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="albow.core.ui.RootWidget.RootWidget.clicked_widget"><code class="name">var <span class="ident">clicked_widget</span></code></dt>
<dd>
<section class="desc"><p>Target of mouse_drag and mouse_up events</p></section>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.do_draw"><code class="name">var <span class="ident">do_draw</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.frame_time"><code class="name">var <span class="ident">frame_time</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.last_mouse_event"><code class="name">var <span class="ident">last_mouse_event</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.last_mouse_event_handler"><code class="name">var <span class="ident">last_mouse_event_handler</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.nextFrameDue"><code class="name">var <span class="ident">nextFrameDue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.ourTimerEvent"><code class="name">var <span class="ident">ourTimerEvent</span></code></dt>
<dd>
<section class="desc"><p>Timer event pending delivery</p></section>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.root_widget"><code class="name">var <span class="ident">root_widget</span></code></dt>
<dd>
<section class="desc"><p>Root of the containment hierarchy</p></section>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.top_widget"><code class="name">var <span class="ident">top_widget</span></code></dt>
<dd>
<section class="desc"><p>Initial dispatch target</p></section>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.userEventCallList"><code class="name">var <span class="ident">userEventCallList</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="albow.core.ui.RootWidget.RootWidget.addUserEvent"><code class="name flex">
<span>def <span class="ident">addUserEvent</span></span>(<span>newCallback)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def addUserEvent(cls, newCallback: UserEventCall):

    cls.userEventCallList.append(newCallback)
    cls.classLogger.debug(f&#34;add - userEventListSize: {len(cls.userEventCallList)}&#34;)</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.getFocus"><code class="name flex">
<span>def <span class="ident">getFocus</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def getFocus():
    return RootWidget.top_widget.get_focus()</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.getRoot"><code class="name flex">
<span>def <span class="ident">getRoot</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns:
The root widget of the containment hierarchy</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def getRoot():
    &#34;&#34;&#34;
    Returns:  The root widget of the containment hierarchy
    &#34;&#34;&#34;
    return RootWidget.root_widget</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.getTopWidget"><code class="name flex">
<span>def <span class="ident">getTopWidget</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def getTopWidget():
    return RootWidget.top_widget</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.getUserEventList"><code class="name flex">
<span>def <span class="ident">getUserEventList</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def getUserEventList(cls):
    cls.classLogger.debug(f&#34;get - userEventListSize: {len(cls.userEventCallList)}&#34;)
    return cls.userEventCallList</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="albow.core.ui.RootWidget.RootWidget.begin_frame"><code class="name flex">
<span>def <span class="ident">begin_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Deprecated, use timer_event() instead.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def begin_frame(self):
    &#34;&#34;&#34;Deprecated, use timer_event() instead.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.confirm_quit"><code class="name flex">
<span>def <span class="ident">confirm_quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Called to give an opportunity to ask the user to confirm quitting the main event loop. If it returns
true, sys.exit(0) is performed, otherwise nothing is done. The default implementation unconditionally
returns true.</p>
<p>Returns: True to confirm else False</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def confirm_quit(self) -&gt; bool:
    &#34;&#34;&#34;
    Called to give an opportunity to ask the user to confirm quitting the main event loop. If it returns
    true, sys.exit(0) is performed, otherwise nothing is done. The default implementation unconditionally
    returns true.

    Returns: True to confirm else False

    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.defer_drawing"><code class="name flex">
<span>def <span class="ident">defer_drawing</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>f this method returns true, pending display updates are only performed when a timer event occurs and the
timer_event() method of the root widget returns true. Otherwise, the display is updated after every input
event except for mouse-move events. The default implementation returns True.</p>
<p>Returns: True to defer else False</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def defer_drawing(self) -&gt; bool:
    &#34;&#34;&#34;
    f this method returns true, pending display updates are only performed when a timer event occurs and the
    timer_event() method of the root widget returns true. Otherwise, the display is updated after every input
    event except for mouse-move events. The default implementation returns True.

    Returns: True to defer else False

    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.get_mouse_for"><code class="name flex">
<span>def <span class="ident">get_mouse_for</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_mouse_for(self, widget):
    last = RootWidget.last_mouse_event
    event = Event(0, last.dict)
    event.dict[&#39;local&#39;] = widget.global_to_local(event.pos)
    CoreUtilities.add_modifiers(event)
    return event</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.music_end"><code class="name flex">
<span>def <span class="ident">music_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def music_end(self):
    MusicUtilities.music_end()</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This method is called when a QUIT event is received. The default implementation first calls
confirm_quit(), and if it returns true, calls sys.exit(0).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def quit(self):
    &#34;&#34;&#34;
    This method is called when a QUIT event is received. The default implementation first calls
    confirm_quit(), and if it returns true, calls sys.exit(0).
    &#34;&#34;&#34;
    if self.confirm_quit():
        sys.exit(0)</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.report_error"><code class="name flex">
<span>def <span class="ident">report_error</span></span>(<span>self, e)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def report_error(self, e):
    pass</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Runs the main event loop. Control is retained until a QUIT event is received, whereupon the quit() method
is called.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    Runs the main event loop. Control is retained until a QUIT event is received, whereupon the quit() method
    is called.

    &#34;&#34;&#34;
    self.run_modal(cast(Widget, None))</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.run_modal"><code class="name flex">
<span>def <span class="ident">run_modal</span></span>(<span>self, modal_widget)</span>
</code></dt>
<dd>
<section class="desc"><p>Runs a modal event loop. The widget is run as a modal dialog until its dismiss() method is called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>modal_widget</code></strong></dt>
<dd>The modal widget</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def run_modal(self, modal_widget: Widget):
    &#34;&#34;&#34;
        Runs a modal event loop. The widget is run as a modal dialog until its dismiss() method is called.
    Args:
        modal_widget:  The modal widget
    &#34;&#34;&#34;
    is_modal = modal_widget is not None
    modal_widget = modal_widget or self
    relative_pause = False
    relative_warmup = 0

    was_modal = None
    try:
        RootWidget.old_top_widget = RootWidget.top_widget
        RootWidget.top_widget = modal_widget
        was_modal = modal_widget.is_modal
        modal_widget.is_modal = True

        modal_widget.modal_result = None
        if not modal_widget.focus_switch:
            modal_widget.tab_to_first()

        self.do_draw = True
        use_sleep = self._use_sleep

        from albow.core.ui.AlbowEventLoop import AlbowEventLoop
        from albow.core.ui.EventLoopParams import EventLoopParams

        eventLoop: AlbowEventLoop = AlbowEventLoop(modalWidget=modal_widget, containingWidget=self)

        last_click_time = 0
        num_clicks = 0
        while modal_widget.modal_result is None:

            defer_drawing = self.frame_time != 0.0 and modal_widget.defer_drawing()
            try:
                if not is_modal:
                    if RootWidget.ourTimerEvent:
                        if not use_sleep and defer_drawing:
                            Scheduler.make_scheduled_calls()
                        CoreUtilities.add_modifiers(RootWidget.ourTimerEvent)
                        if RootWidget.last_mouse_event:
                            RootWidget.ourTimerEvent.dict[&#39;pos&#39;] = RootWidget.last_mouse_event.pos
                            RootWidget.ourTimerEvent.dict[&#39;local&#39;] = RootWidget.last_mouse_event.local
                        if RootWidget.last_mouse_event_handler:
                            RootWidget.last_mouse_event_handler.setup_cursor(RootWidget.ourTimerEvent)
                        self.do_draw = self.timer_event(RootWidget.ourTimerEvent)
                        RootWidget.ourTimerEvent = None
                    else:
                        if defer_drawing:
                            self.do_draw = False
                # RootWidget.classLogger.info(f&#34;self.do_draw: {self.do_draw}&#34;)
                if self.do_draw:
                    if self.is_gl:
                        gl_surface = self.gl_surface
                        gl_surface.gl_clear(self.bg_color)
                        self.gl_draw_all(gl_surface)
                        gl_surface.gl_flush()
                    else:
                        self.draw_all(self.surface)
                    self.do_draw = False
                    # tb1 = timestamp() ###
                    pygame.display.flip()

                in_relative_mode = bool(modal_widget.relative_mode())
                grab = in_relative_mode and not relative_pause
                if grab != get_grab():
                    set_grab(grab)
                    set_mouse_visible(not grab)
                    relative_warmup = 3            # Ignore spurious deltas on entering relative mode
                if use_sleep and defer_drawing:

                    time_now = Scheduler.timestamp()

                    if RootWidget.nextFrameDue &lt; time_now:
                        RootWidget.nextFrameDue = time_now

                    while True:
                        sleep_time = Scheduler.make_due_calls(time_now, RootWidget.nextFrameDue)
                        if sleep_time &lt;= 0.0:
                            break

                        sleep(sleep_time / 1000.0)
                        time_now = Scheduler.timestamp()
                    RootWidget.nextFrameDue += self.frame_time
                    RootWidget.ourTimerEvent = Event(USEREVENT, {&#39;time&#39;: time_now})
                    events = []
                else:
                    events = [pygame.event.wait()]
                events.extend(pygame.event.get())

                loopParams: EventLoopParams = EventLoopParams(use_sleep=use_sleep, relative_pause=relative_pause, do_draw=self.do_draw,
                                                              relative_warmup=relative_warmup, last_click_time=last_click_time,
                                                              num_clicks=num_clicks)

                newParams: EventLoopParams = eventLoop.processEvents(eventList=events, relativeMode=in_relative_mode, deferDrawing=defer_drawing,
                                                                     eventLoopParams=loopParams)

                use_sleep = newParams.use_sleep
                relative_pause = newParams.relative_pause
                self.do_draw = newParams.do_draw
                relative_warmup = newParams.relative_warmup
                last_click_time = newParams.last_click_time
                num_clicks = newParams.num_clicks

            except CancelException:
                pass

            except ApplicationException as e:
                self.report_error(e)
    finally:
        modal_widget.is_modal = was_modal
        RootWidget.top_widget = RootWidget.old_top_widget

    RootWidget.clicked_widget = None</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.send_key"><code class="name flex">
<span>def <span class="ident">send_key</span></span>(<span>self, widget, name, event)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def send_key(self, widget, name, event):
    CoreUtilities.add_modifiers(event)
    widget.dispatch_key(name, event)</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.set_timer"><code class="name flex">
<span>def <span class="ident">set_timer</span></span>(<span>self, ms)</span>
</code></dt>
<dd>
<section class="desc"><p>Arranges for timer events to be generated every interval milliseconds. See timer_event().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ms</code></strong></dt>
<dd>The timer interval in milli-seconds</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_timer(self, ms):
    &#34;&#34;&#34;
    Arranges for timer events to be generated every interval milliseconds. See timer_event().

    Args:
        ms:  The timer interval in milli-seconds

    &#34;&#34;&#34;
    self.frame_time = ms
    if not self._use_sleep:
        set_pygame_timer(USEREVENT, max(1, int(round(ms))))</code></pre>
</details>
</dd>
<dt id="albow.core.ui.RootWidget.RootWidget.timer_event"><code class="name flex">
<span>def <span class="ident">timer_event</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when a timer event occurs. See set_timer(). If it returns true, a display update is performed. The
default implementation returns true.</p>
<h2 id="note">Note</h2>
<p>If multiple timer events occur during a single pass through the event loop, only the most recent
one is passed to timer_event() and the others are discarded. Also, if other types of event occur during
the same pass through the event loop, all the other events are processed before calling timer_event(), even
if the timer event was not the last to occur chronologically.</p>
<h2 id="args">Args</h2>
<dl>
<dt>event:</dt>
<dt><strong><code>Returns</code></strong> :&ensp; <code>True</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def timer_event(self, event):
    &#34;&#34;&#34;
    Called when a timer event occurs. See set_timer(). If it returns true, a display update is performed. The
    default implementation returns true.

    Note:
        If multiple timer events occur during a single pass through the event loop, only the most recent
        one is passed to timer_event() and the others are discarded. Also, if other types of event occur during
        the same pass through the event loop, all the other events are processed before calling timer_event(), even
        if the timer event was not the last to occur chronologically.

    Args:
        event:

    Returns:  True

    &#34;&#34;&#34;
    self.begin_frame()
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="albow.core.ui.Widget.Widget" href="Widget.html#albow.core.ui.Widget.Widget">Widget</a></b></code>:
<ul class="hlist">
<li><code><a title="albow.core.ui.Widget.Widget.add" href="Widget.html#albow.core.ui.Widget.Widget.add">add</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.add_anchor" href="Widget.html#albow.core.ui.Widget.Widget.add_anchor">add_anchor</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.add_centered" href="Widget.html#albow.core.ui.Widget.Widget.add_centered">add_centered</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.anchor" href="AlbowRect.html#albow.core.ui.AlbowRect.AlbowRect.anchor">anchor</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.attention_lost" href="Widget.html#albow.core.ui.Widget.Widget.attention_lost">attention_lost</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.augment_mouse_event" href="Widget.html#albow.core.ui.Widget.Widget.augment_mouse_event">augment_mouse_event</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.bg_color" href="Widget.html#albow.core.ui.Widget.Widget.bg_color">bg_color</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.bg_image" href="Widget.html#albow.core.ui.Widget.Widget.bg_image">bg_image</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.border_color" href="Widget.html#albow.core.ui.Widget.Widget.border_color">border_color</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.border_width" href="Widget.html#albow.core.ui.Widget.Widget.border_width">border_width</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.call_handler" href="Widget.html#albow.core.ui.Widget.Widget.call_handler">call_handler</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.call_parent_handler" href="Widget.html#albow.core.ui.Widget.Widget.call_parent_handler">call_parent_handler</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.dismiss" href="Widget.html#albow.core.ui.Widget.Widget.dismiss">dismiss</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.draw" href="Widget.html#albow.core.ui.Widget.Widget.draw">draw</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.draw_over" href="Widget.html#albow.core.ui.Widget.Widget.draw_over">draw_over</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.fg_color" href="Widget.html#albow.core.ui.Widget.Widget.fg_color">fg_color</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.focus" href="Widget.html#albow.core.ui.Widget.Widget.focus">focus</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.focus_switch" href="Widget.html#albow.core.ui.Widget.Widget.focus_switch">focus_switch</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.font" href="Widget.html#albow.core.ui.Widget.Widget.font">font</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.get_cursor" href="Widget.html#albow.core.ui.Widget.Widget.get_cursor">get_cursor</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.get_focus" href="Widget.html#albow.core.ui.Widget.Widget.get_focus">get_focus</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.get_margin_rect" href="Widget.html#albow.core.ui.Widget.Widget.get_margin_rect">get_margin_rect</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.get_root" href="Widget.html#albow.core.ui.Widget.Widget.get_root">get_root</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.get_top_widget" href="Widget.html#albow.core.ui.Widget.Widget.get_top_widget">get_top_widget</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.get_visible" href="Widget.html#albow.core.ui.Widget.Widget.get_visible">get_visible</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.global_to_local" href="AlbowRect.html#albow.core.ui.AlbowRect.AlbowRect.global_to_local">global_to_local</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.has_focus" href="Widget.html#albow.core.ui.Widget.Widget.has_focus">has_focus</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.inherited" href="Widget.html#albow.core.ui.Widget.Widget.inherited">inherited</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.invalidate" href="Widget.html#albow.core.ui.Widget.Widget.invalidate">invalidate</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.is_gl_container" href="Widget.html#albow.core.ui.Widget.Widget.is_gl_container">is_gl_container</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.key_down" href="Widget.html#albow.core.ui.Widget.Widget.key_down">key_down</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.key_up" href="Widget.html#albow.core.ui.Widget.Widget.key_up">key_up</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.local_to_global" href="AlbowRect.html#albow.core.ui.AlbowRect.AlbowRect.local_to_global">local_to_global</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.margin" href="Widget.html#albow.core.ui.Widget.Widget.margin">margin</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.menu_bar" href="Widget.html#albow.core.ui.Widget.Widget.menu_bar">menu_bar</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.parent" href="Widget.html#albow.core.ui.Widget.Widget.parent">parent</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.parent_resized" href="AlbowRect.html#albow.core.ui.AlbowRect.AlbowRect.parent_resized">parent_resized</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.present" href="Widget.html#albow.core.ui.Widget.Widget.present">present</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.rect" href="AlbowRect.html#albow.core.ui.AlbowRect.AlbowRect.rect">rect</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.relative_mode" href="Widget.html#albow.core.ui.Widget.Widget.relative_mode">relative_mode</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.remove" href="Widget.html#albow.core.ui.Widget.Widget.remove">remove</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.remove_anchor" href="Widget.html#albow.core.ui.Widget.Widget.remove_anchor">remove_anchor</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.resized" href="AlbowRect.html#albow.core.ui.AlbowRect.AlbowRect.resized">resized</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.scale_bg" href="Widget.html#albow.core.ui.Widget.Widget.scale_bg">scale_bg</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.sel_color" href="Widget.html#albow.core.ui.Widget.Widget.sel_color">sel_color</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.set_parent" href="Widget.html#albow.core.ui.Widget.Widget.set_parent">set_parent</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.set_size_for_text" href="Widget.html#albow.core.ui.Widget.Widget.set_size_for_text">set_size_for_text</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.tab_stop" href="Widget.html#albow.core.ui.Widget.Widget.tab_stop">tab_stop</a></code></li>
<li><code><a title="albow.core.ui.Widget.Widget.visible" href="Widget.html#albow.core.ui.Widget.Widget.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="albow.core.ui" href="index.html">albow.core.ui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="albow.core.ui.RootWidget.RootWidget" href="#albow.core.ui.RootWidget.RootWidget">RootWidget</a></code></h4>
<ul class="">
<li><code><a title="albow.core.ui.RootWidget.RootWidget.addUserEvent" href="#albow.core.ui.RootWidget.RootWidget.addUserEvent">addUserEvent</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.begin_frame" href="#albow.core.ui.RootWidget.RootWidget.begin_frame">begin_frame</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.clicked_widget" href="#albow.core.ui.RootWidget.RootWidget.clicked_widget">clicked_widget</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.confirm_quit" href="#albow.core.ui.RootWidget.RootWidget.confirm_quit">confirm_quit</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.defer_drawing" href="#albow.core.ui.RootWidget.RootWidget.defer_drawing">defer_drawing</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.do_draw" href="#albow.core.ui.RootWidget.RootWidget.do_draw">do_draw</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.frame_time" href="#albow.core.ui.RootWidget.RootWidget.frame_time">frame_time</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.getFocus" href="#albow.core.ui.RootWidget.RootWidget.getFocus">getFocus</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.getRoot" href="#albow.core.ui.RootWidget.RootWidget.getRoot">getRoot</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.getTopWidget" href="#albow.core.ui.RootWidget.RootWidget.getTopWidget">getTopWidget</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.getUserEventList" href="#albow.core.ui.RootWidget.RootWidget.getUserEventList">getUserEventList</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.get_mouse_for" href="#albow.core.ui.RootWidget.RootWidget.get_mouse_for">get_mouse_for</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.last_mouse_event" href="#albow.core.ui.RootWidget.RootWidget.last_mouse_event">last_mouse_event</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.last_mouse_event_handler" href="#albow.core.ui.RootWidget.RootWidget.last_mouse_event_handler">last_mouse_event_handler</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.music_end" href="#albow.core.ui.RootWidget.RootWidget.music_end">music_end</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.nextFrameDue" href="#albow.core.ui.RootWidget.RootWidget.nextFrameDue">nextFrameDue</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.ourTimerEvent" href="#albow.core.ui.RootWidget.RootWidget.ourTimerEvent">ourTimerEvent</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.quit" href="#albow.core.ui.RootWidget.RootWidget.quit">quit</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.report_error" href="#albow.core.ui.RootWidget.RootWidget.report_error">report_error</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.root_widget" href="#albow.core.ui.RootWidget.RootWidget.root_widget">root_widget</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.run" href="#albow.core.ui.RootWidget.RootWidget.run">run</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.run_modal" href="#albow.core.ui.RootWidget.RootWidget.run_modal">run_modal</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.send_key" href="#albow.core.ui.RootWidget.RootWidget.send_key">send_key</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.set_timer" href="#albow.core.ui.RootWidget.RootWidget.set_timer">set_timer</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.timer_event" href="#albow.core.ui.RootWidget.RootWidget.timer_event">timer_event</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.top_widget" href="#albow.core.ui.RootWidget.RootWidget.top_widget">top_widget</a></code></li>
<li><code><a title="albow.core.ui.RootWidget.RootWidget.userEventCallList" href="#albow.core.ui.RootWidget.RootWidget.userEventCallList">userEventCallList</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>