<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>albow.core.RootWidget API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>albow.core.RootWidget</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">from typing import List

import sys

from time import sleep

from pygame.locals import *

import pygame
from pygame.mouse import set_visible as set_mouse_visible
from pygame.time import set_timer as set_pygame_timer

from pygame import Surface

from pygame.event import Event
from pygame.event import get_grab
from pygame.event import set_grab

from albow.core.Widget import Widget
from albow.core.Scheduler import Scheduler
from albow.core.CoreUtilities import CoreUtilities
from albow.core.CancelException import CancelException
from albow.core.ApplicationException import ApplicationException

from albow.core.UserEventCall import UserEventCall

from albow.media.MusicUtilities import MusicUtilities


class RootWidget(Widget):

    DOUBLE_CLICK_TIME = 300
    &#34;&#34;&#34;
    Time is in milliseconds
    &#34;&#34;&#34;

    &#34;&#34;&#34;
    For the GUI to function, there must be exactly one instance of RootWidget. It implements the main event loop
    and serves as the ultimate container for all other visible widgets.

    The root widget can be found using the `RootWidget.get_root()`

    &#34;&#34;&#34;
    MUSIC_END_EVENT = USEREVENT + 1
    &#34;&#34;&#34;
    API consumer user events **MUST** start there events after this one
    &#34;&#34;&#34;

    root_widget = None
    &#34;&#34;&#34;
    Root of the containment hierarchy
    &#34;&#34;&#34;
    top_widget = None
    &#34;&#34;&#34;
    Initial dispatch target
    &#34;&#34;&#34;
    clicked_widget = None
    &#34;&#34;&#34;
    Target of mouse_drag and mouse_up events
    &#34;&#34;&#34;

    redraw_every_frame = False
    &#34;&#34;&#34;
    If true, all widgets will be redrawn on every animation frame (i.e. after every call to begin_frame()). If false, 
    redrawing only occurs after user input events, such as mouse clicks and keystrokes, or if a widget calls 
    its invalidate() method. The default is false.
    &#34;&#34;&#34;
    last_mouse_event_handler = None

    ourTimerEvent = None
    &#34;&#34;&#34;
    Timer event pending delivery
    &#34;&#34;&#34;
    nextFrameDue = 0.0

    do_draw          = False
    _is_gl_container = True
    frame_time       = 0.0
    _use_sleep       = True

    last_mouse_event: Event = Event(0, {&#39;pos&#39;: (0, 0), &#39;local&#39;: (0, 0)})

    userEventCallList: List = []

    def __init__(self, surface: Surface, **kwds):
        &#34;&#34;&#34;
        Initializes the root widget with the given surface, which will normally be the PyGame screen,
        but could be a subsurface of it.

        Args:
            surface:  A Pygame surface

            **kwds:
        &#34;&#34;&#34;
        super().__init__(surface.get_rect(), **kwds)

        CoreUtilities.init_timebase()
        self.surface = surface
        RootWidget.root_widget = self
        Widget.root_widget = self
        #
        # Python 3 update
        #
        # self.is_gl = surface.get_flags() &amp; OPENGL &lt;&gt; 0
        self.is_gl = surface.get_flags() &amp; OPENGL != 0
        if self.is_gl:

            from albow.openGL.GLSurface import GLSurface
            self.gl_surface = GLSurface(surface, self.rect)

    def set_timer(self, ms):
        &#34;&#34;&#34;
        Arranges for timer events to be generated every interval milliseconds. See timer_event().

        Args:
            ms:  The timer interval in milli-seconds

        &#34;&#34;&#34;
        self.frame_time = ms
        if not self._use_sleep:
            set_pygame_timer(USEREVENT, max(1, int(round(ms))))

    def run(self):
        &#34;&#34;&#34;
        Runs the main event loop. Control is retained until a QUIT event is received, whereupon the quit() method
        is called.

        &#34;&#34;&#34;
        self.run_modal(None)

    def run_modal(self, modal_widget: Widget):
        &#34;&#34;&#34;
            Runs a modal event loop. The widget is run as a modal dialog until its dismiss() method is called.
        Args:
            modal_widget:  The modal widget
        &#34;&#34;&#34;
        is_modal = modal_widget is not None
        modal_widget = modal_widget or self
        relative_pause = False
        relative_warmup = 0

        was_modal = None
        try:
            RootWidget.old_top_widget = RootWidget.top_widget
            RootWidget.top_widget = modal_widget
            was_modal = modal_widget.is_modal

            modal_widget.is_modal = True
            modal_widget.modal_result = None
            if not modal_widget.focus_switch:

                modal_widget.tab_to_first()

            num_clicks = 0
            last_click_time = 0
            self.do_draw = True
            use_sleep = self._use_sleep
            while modal_widget.modal_result is None:
                # print &#34;RootWidget: frame_time =&#34;, self.frame_time ###
                #
                # Python 3 update
                #
                # defer_drawing = self.frame_time &lt;&gt; 0.0 and modal_widget.defer_drawing()
                defer_drawing = self.frame_time != 0.0 and modal_widget.defer_drawing()
                try:
                    if not is_modal:
                        if RootWidget.ourTimerEvent:
                            if not use_sleep and defer_drawing:
                                Scheduler.make_scheduled_calls()
                            CoreUtilities.add_modifiers(RootWidget.ourTimerEvent)
                            if RootWidget.last_mouse_event:
                                RootWidget.ourTimerEvent.dict[&#39;pos&#39;] = RootWidget.last_mouse_event.pos
                                RootWidget.ourTimerEvent.dict[&#39;local&#39;] = RootWidget.last_mouse_event.local
                            if RootWidget.last_mouse_event_handler:
                                RootWidget.last_mouse_event_handler.setup_cursor(RootWidget.ourTimerEvent)
                            self.do_draw = self.timer_event(RootWidget.ourTimerEvent)
                            RootWidget.ourTimerEvent = None
                        else:
                            if defer_drawing:
                                # print &#34;RootWidget: Clearing do_draw because of defer_drawing&#34; ###
                                self.do_draw = False
                    # print &#34;RootWidget: do_draw =&#34;, self.do_draw ###
                    if self.do_draw:
                        if self.is_gl:
                            # self.gl_clear()
                            # self.gl_draw_all(self, (0, 0))
                            # GL.glFlush()
                            gl_surface = self.gl_surface
                            gl_surface.gl_clear(self.bg_color)
                            self.gl_draw_all(gl_surface)
                            gl_surface.gl_flush()
                        else:
                            self.draw_all(self.surface)
                        self.do_draw = False
                        # tb1 = timestamp() ###
                        pygame.display.flip()
                    # tb2 = timestamp() ###
                    # print &#34;RootWidget: Flip block  %5d&#34; % (tb2 - tb1) ###
                    in_relative_mode = bool(modal_widget.relative_mode())
                    grab = in_relative_mode and not relative_pause
                    # if grab &lt;&gt; get_grab():
                    if grab != get_grab():
                        set_grab(grab)
                        set_mouse_visible(not grab)
                        relative_warmup = 3     # Ignore spurious deltas on entering relative mode
                        # tb1 = timestamp() ###
                        # print &#34;RootWidget: use_sleep =&#34;, use_sleep, &#34;defer_drawing =&#34;, defer_drawing ###
                    if use_sleep and defer_drawing:
                        #  print &#34;RootWidget: Handling timing&#34; ###
                        time_now = Scheduler.timestamp()
                        #  print &#34;RootWidget: Time is now&#34;, time_now ###
                        if RootWidget.nextFrameDue &lt; time_now:
                            #  print &#34;RootWidget: Adjusting next frame due time to time now&#34; ###
                            RootWidget.nextFrameDue = time_now
                            #  print &#34;RootWidget: Waiting for next frame due at&#34;, next_frame_due ###
                        while 1:
                            sleep_time = Scheduler.make_due_calls(time_now, RootWidget.nextFrameDue)
                            if sleep_time &lt;= 0.0:
                                break
                            # print &#34;RootWidget: Sleeping for&#34;, sleep_time ###
                            sleep(sleep_time / 1000.0)
                            time_now = Scheduler.timestamp()
                        RootWidget.nextFrameDue += self.frame_time
                        # print &#34;RootWidget: Next frame now due at&#34;, next_frame_due ###
                        #
                        # Pygame 1.9 update
                        #
                        # timer_event = Event(USEREVENT, time = time_now)
                        RootWidget.ourTimerEvent = Event(USEREVENT)
                        RootWidget.ourTimerEvent.dict[&#39;time&#39;] = time_now

                        events = []
                    else:
                        events = [pygame.event.wait()]
                    # tb2 = timestamp() ###
                    # tb = tb2 - tb1 ###
                    # if tb: ###
                    # print &#34;RootWidget: Event block %5d&#34; % tb ###
                    events.extend(pygame.event.get())
                    for event in events:
                        t = Scheduler.timestamp()
                        event.dict[&#39;time&#39;] = t
                        event.dict[&#39;local&#39;] = getattr(event, &#39;pos&#39;, (0, 0))
                        eventType = event.type
                        if eventType == QUIT:
                            self.quit()
                        elif eventType == MOUSEBUTTONDOWN:
                            # print &#34;RootWidget: MOUSEBUTTONDOWN: setting do_draw&#34; ###
                            self.do_draw = True
                            if t - last_click_time &lt;= RootWidget.DOUBLE_CLICK_TIME:
                                num_clicks += 1
                            else:
                                num_clicks = 1
                            last_click_time = t
                            event.dict[&#39;num_clicks&#39;] = num_clicks
                            CoreUtilities.add_modifiers(event)
                            RootWidget.last_mouse_event = event
                            if in_relative_mode:
                                event.dict[&#39;local&#39;] = (0, 0)
                                if relative_pause:
                                    relative_pause = False
                                else:
                                    #  modal_widget.dispatch_key(&#39;mouse_down&#39;, event)
                                    mouse_widget = modal_widget.get_focus()
                                    RootWidget.clicked_widget = mouse_widget
                                    RootWidget.last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_event(&#39;mouse_down&#39;, event)
                            else:
                                mouse_widget = self.find_widget(event.pos)
                                if not mouse_widget.is_inside(modal_widget):
                                    mouse_widget = modal_widget
                                RootWidget.clicked_widget = mouse_widget
                                RootWidget.last_mouse_event_handler = mouse_widget
                                mouse_widget.notify_attention_loss()
                                mouse_widget.handle_mouse(&#39;mouse_down&#39;, event)
                        elif eventType == MOUSEMOTION:
                            CoreUtilities.add_modifiers(event)
                            RootWidget.last_mouse_event = event
                            if in_relative_mode:
                                event.dict[&#39;local&#39;] = (0, 0)
                                if not relative_pause:
                                    if relative_warmup:
                                        relative_warmup -= 1
                                    else:
                                        #  modal_widget.dispatch_key(&#39;mouse_delta&#39;, event)
                                        mouse_widget = RootWidget.clicked_widget or modal_widget.get_focus()
                                        RootWidget.last_mouse_event_handler = mouse_widget
                                        mouse_widget.handle_event(&#39;mouse_delta&#39;, event)
                            else:
                                mouse_widget = self.find_widget(event.pos)   # Do this in else branch?
                                if RootWidget.clicked_widget:
                                    RootWidget.last_mouse_event_handler = mouse_widget  # Should this be clicked_widget?
                                    RootWidget.clicked_widget.handle_mouse(&#39;mouse_drag&#39;, event)
                                else:
                                    if not mouse_widget.is_inside(modal_widget):
                                        mouse_widget = modal_widget
                                    RootWidget.last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_mouse(&#39;mouse_move&#39;, event)
                        elif eventType == MOUSEBUTTONUP:
                            CoreUtilities.add_modifiers(event)
                            RootWidget.last_mouse_event = event
                            self.do_draw = True
                            if in_relative_mode:
                                event.dict[&#39;local&#39;] = (0, 0)
                                if not relative_pause:

                                    if RootWidget.clicked_widget:
                                        mouse_widget = RootWidget.clicked_widget
                                        RootWidget.clicked_widget = None
                                    else:
                                        mouse_widget = modal_widget.get_focus()
                                    RootWidget.last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_event(&#39;mouse_up&#39;, event)
                            else:
                                if RootWidget.clicked_widget:
                                    RootWidget.last_mouse_event_handler = RootWidget.clicked_widget
                                    RootWidget.clicked_widget = None
                                    RootWidget.last_mouse_event_handler.handle_mouse(&#39;mouse_up&#39;, event)
                        elif eventType == KEYDOWN:
                            key = event.key
                            if key == K_ESCAPE and in_relative_mode and \
                                    event.mod &amp; KMOD_CTRL and event.mod &amp; KMOD_SHIFT:
                                relative_pause = True
                            elif relative_pause:
                                relative_pause = False
                            else:
                                CoreUtilities.set_modifier(key, True)
                                self.do_draw = True
                                self.send_key(modal_widget, &#39;key_down&#39;, event)
                                if RootWidget.last_mouse_event_handler:
                                    event.dict[&#39;pos&#39;] = RootWidget.last_mouse_event.pos
                                    event.dict[&#39;local&#39;] = RootWidget.last_mouse_event.local
                                    RootWidget.last_mouse_event_handler.setup_cursor(event)
                        elif eventType == KEYUP:
                            key = event.key
                            CoreUtilities.set_modifier(key, False)
                            self.do_draw = True
                            self.send_key(modal_widget, &#39;key_up&#39;, event)
                            if RootWidget.last_mouse_event_handler:
                                event.dict[&#39;pos&#39;] = RootWidget.last_mouse_event.pos
                                event.dict[&#39;local&#39;] = RootWidget.last_mouse_event.local
                                RootWidget.last_mouse_event_handler.setup_cursor(event)
                        elif eventType == RootWidget.MUSIC_END_EVENT:
                            self.music_end()
                        elif eventType == USEREVENT:
                            if defer_drawing and not use_sleep:
                                RootWidget.ourTimerEvent = event
                        else:
                            #
                            # Maybe someone has registered some user events handler
                            #
                            for cb in RootWidget.userEventCallList:
                                if cb.userEvent == eventType:
                                    self.logger.debug(f&#34;API User eventType: {eventType}&#34;)
                                    cb.func(event)

                except CancelException:
                    pass
                #
                # Python 3 update
                #
                # except ApplicationError, e:
                except ApplicationException as e:
                    self.report_error(e)
        finally:
            modal_widget.is_modal = was_modal
            RootWidget.top_widget = RootWidget.old_top_widget
        RootWidget.clicked_widget = None

    def send_key(self, widget, name, event):
        CoreUtilities.add_modifiers(event)
        widget.dispatch_key(name, event)

    def begin_frame(self):
        &#34;&#34;&#34;Deprecated, use timer_event() instead.&#34;&#34;&#34;
        pass

    def has_focus(self):
        return True

    def quit(self):
        &#34;&#34;&#34;
        This method is called when a QUIT event is received. The default implementation first calls
        confirm_quit(), and if it returns true, calls sys.exit(0).
        &#34;&#34;&#34;
        if self.confirm_quit():
            sys.exit(0)

    def get_mouse_for(self, widget):
        last = RootWidget.last_mouse_event
        event = Event(0, last.dict)
        event.dict[&#39;local&#39;] = widget.global_to_local(event.pos)
        CoreUtilities.add_modifiers(event)
        return event

    def music_end(self):
        MusicUtilities.music_end()

    @staticmethod
    def getRoot():
        &#34;&#34;&#34;
        Returns:  The root widget of the containment hierarchy
        &#34;&#34;&#34;
        return RootWidget.root_widget

    @staticmethod
    def getTopWidget():
        return RootWidget.top_widget

    @staticmethod
    def getFocus():
        return RootWidget.top_widget.get_focus()

    @staticmethod
    def addUserEvent(newCallback: UserEventCall):

        RootWidget.userEventCallList.append(newCallback)

    # ========================================================================
    #
    #  Abstract methods follow
    #
    # ========================================================================

    def report_error(self, e):
        pass

    def confirm_quit(self) -&gt; bool:
        &#34;&#34;&#34;
        Called to give an opportunity to ask the user to confirm quitting the main event loop. If it returns
        true, sys.exit(0) is performed, otherwise nothing is done. The default implementation unconditionally
        returns true.

        Returns: True to confirm else False

        &#34;&#34;&#34;
        return True

    def defer_drawing(self) -&gt; bool:
        &#34;&#34;&#34;
        f this method returns true, pending display updates are only performed when a timer event occurs and the
        timer_event() method of the root widget returns true. Otherwise, the display is updated after every input
        event except for mouse-move events. The default implementation returns True.

        Returns: True to defer else False

        &#34;&#34;&#34;
        return True

    def timer_event(self, event):
        &#34;&#34;&#34;
        Called when a timer event occurs. See set_timer(). If it returns true, a display update is performed. The
        default implementation returns true.

        Note:
            If multiple timer events occur during a single pass through the event loop, only the most recent
            one is passed to timer_event() and the others are discarded. Also, if other types of event occur during
            the same pass through the event loop, all the other events are processed before calling timer_event(), even
            if the timer event was not the last to occur chronologically.

        Args:
            event:

        Returns:  True

        &#34;&#34;&#34;
        self.begin_frame()
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="albow.core.RootWidget.RootWidget"><code class="flex name class">
<span>class <span class="ident">RootWidget</span></span>
<span>(</span><span>surface, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>The Widget class is the base class for all widgets. A widget occupies a rectangular area of the PyGame screen
to which all drawing in it is clipped, and it may receive mouse and keyboard events. A widget may also
contain subwidgets.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Due to a limitation of PyGame subsurfaces, a widget's rectangle must be entirely contained within that of
its parent widget. An exception will occur if this is violated.</p>
</div>
<ul>
<li>Reading the following attributes retrieves the corresponding values from the widget's rect.</li>
<li>Assigning to them changes the size and position of the widget.</li>
<li>
<p>Additionally, if the size of the widget is changed via these
attributes, the size and position of its subwidgets is updated according to each subwidget's anchor attribute.</p>
<p><pre>
left, right, top, bottom, width, height, size,
topleft, topright, bottomleft, bottomright,
midleft, midright, midtop, midbottom,
center, centerx, centery
</pre></p>
</li>
</ul>
<p>This does not happen if the rect is modified directly.</p>
<p>Initializes the root widget with the given surface, which will normally be the PyGame screen,
but could be a subsurface of it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>surface</code></strong></dt>
<dd>A Pygame surface</dd>
</dl>
<p>**kwds:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class RootWidget(Widget):

    DOUBLE_CLICK_TIME = 300
    &#34;&#34;&#34;
    Time is in milliseconds
    &#34;&#34;&#34;

    &#34;&#34;&#34;
    For the GUI to function, there must be exactly one instance of RootWidget. It implements the main event loop
    and serves as the ultimate container for all other visible widgets.

    The root widget can be found using the `RootWidget.get_root()`

    &#34;&#34;&#34;
    MUSIC_END_EVENT = USEREVENT + 1
    &#34;&#34;&#34;
    API consumer user events **MUST** start there events after this one
    &#34;&#34;&#34;

    root_widget = None
    &#34;&#34;&#34;
    Root of the containment hierarchy
    &#34;&#34;&#34;
    top_widget = None
    &#34;&#34;&#34;
    Initial dispatch target
    &#34;&#34;&#34;
    clicked_widget = None
    &#34;&#34;&#34;
    Target of mouse_drag and mouse_up events
    &#34;&#34;&#34;

    redraw_every_frame = False
    &#34;&#34;&#34;
    If true, all widgets will be redrawn on every animation frame (i.e. after every call to begin_frame()). If false, 
    redrawing only occurs after user input events, such as mouse clicks and keystrokes, or if a widget calls 
    its invalidate() method. The default is false.
    &#34;&#34;&#34;
    last_mouse_event_handler = None

    ourTimerEvent = None
    &#34;&#34;&#34;
    Timer event pending delivery
    &#34;&#34;&#34;
    nextFrameDue = 0.0

    do_draw          = False
    _is_gl_container = True
    frame_time       = 0.0
    _use_sleep       = True

    last_mouse_event: Event = Event(0, {&#39;pos&#39;: (0, 0), &#39;local&#39;: (0, 0)})

    userEventCallList: List = []

    def __init__(self, surface: Surface, **kwds):
        &#34;&#34;&#34;
        Initializes the root widget with the given surface, which will normally be the PyGame screen,
        but could be a subsurface of it.

        Args:
            surface:  A Pygame surface

            **kwds:
        &#34;&#34;&#34;
        super().__init__(surface.get_rect(), **kwds)

        CoreUtilities.init_timebase()
        self.surface = surface
        RootWidget.root_widget = self
        Widget.root_widget = self
        #
        # Python 3 update
        #
        # self.is_gl = surface.get_flags() &amp; OPENGL &lt;&gt; 0
        self.is_gl = surface.get_flags() &amp; OPENGL != 0
        if self.is_gl:

            from albow.openGL.GLSurface import GLSurface
            self.gl_surface = GLSurface(surface, self.rect)

    def set_timer(self, ms):
        &#34;&#34;&#34;
        Arranges for timer events to be generated every interval milliseconds. See timer_event().

        Args:
            ms:  The timer interval in milli-seconds

        &#34;&#34;&#34;
        self.frame_time = ms
        if not self._use_sleep:
            set_pygame_timer(USEREVENT, max(1, int(round(ms))))

    def run(self):
        &#34;&#34;&#34;
        Runs the main event loop. Control is retained until a QUIT event is received, whereupon the quit() method
        is called.

        &#34;&#34;&#34;
        self.run_modal(None)

    def run_modal(self, modal_widget: Widget):
        &#34;&#34;&#34;
            Runs a modal event loop. The widget is run as a modal dialog until its dismiss() method is called.
        Args:
            modal_widget:  The modal widget
        &#34;&#34;&#34;
        is_modal = modal_widget is not None
        modal_widget = modal_widget or self
        relative_pause = False
        relative_warmup = 0

        was_modal = None
        try:
            RootWidget.old_top_widget = RootWidget.top_widget
            RootWidget.top_widget = modal_widget
            was_modal = modal_widget.is_modal

            modal_widget.is_modal = True
            modal_widget.modal_result = None
            if not modal_widget.focus_switch:

                modal_widget.tab_to_first()

            num_clicks = 0
            last_click_time = 0
            self.do_draw = True
            use_sleep = self._use_sleep
            while modal_widget.modal_result is None:
                # print &#34;RootWidget: frame_time =&#34;, self.frame_time ###
                #
                # Python 3 update
                #
                # defer_drawing = self.frame_time &lt;&gt; 0.0 and modal_widget.defer_drawing()
                defer_drawing = self.frame_time != 0.0 and modal_widget.defer_drawing()
                try:
                    if not is_modal:
                        if RootWidget.ourTimerEvent:
                            if not use_sleep and defer_drawing:
                                Scheduler.make_scheduled_calls()
                            CoreUtilities.add_modifiers(RootWidget.ourTimerEvent)
                            if RootWidget.last_mouse_event:
                                RootWidget.ourTimerEvent.dict[&#39;pos&#39;] = RootWidget.last_mouse_event.pos
                                RootWidget.ourTimerEvent.dict[&#39;local&#39;] = RootWidget.last_mouse_event.local
                            if RootWidget.last_mouse_event_handler:
                                RootWidget.last_mouse_event_handler.setup_cursor(RootWidget.ourTimerEvent)
                            self.do_draw = self.timer_event(RootWidget.ourTimerEvent)
                            RootWidget.ourTimerEvent = None
                        else:
                            if defer_drawing:
                                # print &#34;RootWidget: Clearing do_draw because of defer_drawing&#34; ###
                                self.do_draw = False
                    # print &#34;RootWidget: do_draw =&#34;, self.do_draw ###
                    if self.do_draw:
                        if self.is_gl:
                            # self.gl_clear()
                            # self.gl_draw_all(self, (0, 0))
                            # GL.glFlush()
                            gl_surface = self.gl_surface
                            gl_surface.gl_clear(self.bg_color)
                            self.gl_draw_all(gl_surface)
                            gl_surface.gl_flush()
                        else:
                            self.draw_all(self.surface)
                        self.do_draw = False
                        # tb1 = timestamp() ###
                        pygame.display.flip()
                    # tb2 = timestamp() ###
                    # print &#34;RootWidget: Flip block  %5d&#34; % (tb2 - tb1) ###
                    in_relative_mode = bool(modal_widget.relative_mode())
                    grab = in_relative_mode and not relative_pause
                    # if grab &lt;&gt; get_grab():
                    if grab != get_grab():
                        set_grab(grab)
                        set_mouse_visible(not grab)
                        relative_warmup = 3     # Ignore spurious deltas on entering relative mode
                        # tb1 = timestamp() ###
                        # print &#34;RootWidget: use_sleep =&#34;, use_sleep, &#34;defer_drawing =&#34;, defer_drawing ###
                    if use_sleep and defer_drawing:
                        #  print &#34;RootWidget: Handling timing&#34; ###
                        time_now = Scheduler.timestamp()
                        #  print &#34;RootWidget: Time is now&#34;, time_now ###
                        if RootWidget.nextFrameDue &lt; time_now:
                            #  print &#34;RootWidget: Adjusting next frame due time to time now&#34; ###
                            RootWidget.nextFrameDue = time_now
                            #  print &#34;RootWidget: Waiting for next frame due at&#34;, next_frame_due ###
                        while 1:
                            sleep_time = Scheduler.make_due_calls(time_now, RootWidget.nextFrameDue)
                            if sleep_time &lt;= 0.0:
                                break
                            # print &#34;RootWidget: Sleeping for&#34;, sleep_time ###
                            sleep(sleep_time / 1000.0)
                            time_now = Scheduler.timestamp()
                        RootWidget.nextFrameDue += self.frame_time
                        # print &#34;RootWidget: Next frame now due at&#34;, next_frame_due ###
                        #
                        # Pygame 1.9 update
                        #
                        # timer_event = Event(USEREVENT, time = time_now)
                        RootWidget.ourTimerEvent = Event(USEREVENT)
                        RootWidget.ourTimerEvent.dict[&#39;time&#39;] = time_now

                        events = []
                    else:
                        events = [pygame.event.wait()]
                    # tb2 = timestamp() ###
                    # tb = tb2 - tb1 ###
                    # if tb: ###
                    # print &#34;RootWidget: Event block %5d&#34; % tb ###
                    events.extend(pygame.event.get())
                    for event in events:
                        t = Scheduler.timestamp()
                        event.dict[&#39;time&#39;] = t
                        event.dict[&#39;local&#39;] = getattr(event, &#39;pos&#39;, (0, 0))
                        eventType = event.type
                        if eventType == QUIT:
                            self.quit()
                        elif eventType == MOUSEBUTTONDOWN:
                            # print &#34;RootWidget: MOUSEBUTTONDOWN: setting do_draw&#34; ###
                            self.do_draw = True
                            if t - last_click_time &lt;= RootWidget.DOUBLE_CLICK_TIME:
                                num_clicks += 1
                            else:
                                num_clicks = 1
                            last_click_time = t
                            event.dict[&#39;num_clicks&#39;] = num_clicks
                            CoreUtilities.add_modifiers(event)
                            RootWidget.last_mouse_event = event
                            if in_relative_mode:
                                event.dict[&#39;local&#39;] = (0, 0)
                                if relative_pause:
                                    relative_pause = False
                                else:
                                    #  modal_widget.dispatch_key(&#39;mouse_down&#39;, event)
                                    mouse_widget = modal_widget.get_focus()
                                    RootWidget.clicked_widget = mouse_widget
                                    RootWidget.last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_event(&#39;mouse_down&#39;, event)
                            else:
                                mouse_widget = self.find_widget(event.pos)
                                if not mouse_widget.is_inside(modal_widget):
                                    mouse_widget = modal_widget
                                RootWidget.clicked_widget = mouse_widget
                                RootWidget.last_mouse_event_handler = mouse_widget
                                mouse_widget.notify_attention_loss()
                                mouse_widget.handle_mouse(&#39;mouse_down&#39;, event)
                        elif eventType == MOUSEMOTION:
                            CoreUtilities.add_modifiers(event)
                            RootWidget.last_mouse_event = event
                            if in_relative_mode:
                                event.dict[&#39;local&#39;] = (0, 0)
                                if not relative_pause:
                                    if relative_warmup:
                                        relative_warmup -= 1
                                    else:
                                        #  modal_widget.dispatch_key(&#39;mouse_delta&#39;, event)
                                        mouse_widget = RootWidget.clicked_widget or modal_widget.get_focus()
                                        RootWidget.last_mouse_event_handler = mouse_widget
                                        mouse_widget.handle_event(&#39;mouse_delta&#39;, event)
                            else:
                                mouse_widget = self.find_widget(event.pos)   # Do this in else branch?
                                if RootWidget.clicked_widget:
                                    RootWidget.last_mouse_event_handler = mouse_widget  # Should this be clicked_widget?
                                    RootWidget.clicked_widget.handle_mouse(&#39;mouse_drag&#39;, event)
                                else:
                                    if not mouse_widget.is_inside(modal_widget):
                                        mouse_widget = modal_widget
                                    RootWidget.last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_mouse(&#39;mouse_move&#39;, event)
                        elif eventType == MOUSEBUTTONUP:
                            CoreUtilities.add_modifiers(event)
                            RootWidget.last_mouse_event = event
                            self.do_draw = True
                            if in_relative_mode:
                                event.dict[&#39;local&#39;] = (0, 0)
                                if not relative_pause:

                                    if RootWidget.clicked_widget:
                                        mouse_widget = RootWidget.clicked_widget
                                        RootWidget.clicked_widget = None
                                    else:
                                        mouse_widget = modal_widget.get_focus()
                                    RootWidget.last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_event(&#39;mouse_up&#39;, event)
                            else:
                                if RootWidget.clicked_widget:
                                    RootWidget.last_mouse_event_handler = RootWidget.clicked_widget
                                    RootWidget.clicked_widget = None
                                    RootWidget.last_mouse_event_handler.handle_mouse(&#39;mouse_up&#39;, event)
                        elif eventType == KEYDOWN:
                            key = event.key
                            if key == K_ESCAPE and in_relative_mode and \
                                    event.mod &amp; KMOD_CTRL and event.mod &amp; KMOD_SHIFT:
                                relative_pause = True
                            elif relative_pause:
                                relative_pause = False
                            else:
                                CoreUtilities.set_modifier(key, True)
                                self.do_draw = True
                                self.send_key(modal_widget, &#39;key_down&#39;, event)
                                if RootWidget.last_mouse_event_handler:
                                    event.dict[&#39;pos&#39;] = RootWidget.last_mouse_event.pos
                                    event.dict[&#39;local&#39;] = RootWidget.last_mouse_event.local
                                    RootWidget.last_mouse_event_handler.setup_cursor(event)
                        elif eventType == KEYUP:
                            key = event.key
                            CoreUtilities.set_modifier(key, False)
                            self.do_draw = True
                            self.send_key(modal_widget, &#39;key_up&#39;, event)
                            if RootWidget.last_mouse_event_handler:
                                event.dict[&#39;pos&#39;] = RootWidget.last_mouse_event.pos
                                event.dict[&#39;local&#39;] = RootWidget.last_mouse_event.local
                                RootWidget.last_mouse_event_handler.setup_cursor(event)
                        elif eventType == RootWidget.MUSIC_END_EVENT:
                            self.music_end()
                        elif eventType == USEREVENT:
                            if defer_drawing and not use_sleep:
                                RootWidget.ourTimerEvent = event
                        else:
                            #
                            # Maybe someone has registered some user events handler
                            #
                            for cb in RootWidget.userEventCallList:
                                if cb.userEvent == eventType:
                                    self.logger.debug(f&#34;API User eventType: {eventType}&#34;)
                                    cb.func(event)

                except CancelException:
                    pass
                #
                # Python 3 update
                #
                # except ApplicationError, e:
                except ApplicationException as e:
                    self.report_error(e)
        finally:
            modal_widget.is_modal = was_modal
            RootWidget.top_widget = RootWidget.old_top_widget
        RootWidget.clicked_widget = None

    def send_key(self, widget, name, event):
        CoreUtilities.add_modifiers(event)
        widget.dispatch_key(name, event)

    def begin_frame(self):
        &#34;&#34;&#34;Deprecated, use timer_event() instead.&#34;&#34;&#34;
        pass

    def has_focus(self):
        return True

    def quit(self):
        &#34;&#34;&#34;
        This method is called when a QUIT event is received. The default implementation first calls
        confirm_quit(), and if it returns true, calls sys.exit(0).
        &#34;&#34;&#34;
        if self.confirm_quit():
            sys.exit(0)

    def get_mouse_for(self, widget):
        last = RootWidget.last_mouse_event
        event = Event(0, last.dict)
        event.dict[&#39;local&#39;] = widget.global_to_local(event.pos)
        CoreUtilities.add_modifiers(event)
        return event

    def music_end(self):
        MusicUtilities.music_end()

    @staticmethod
    def getRoot():
        &#34;&#34;&#34;
        Returns:  The root widget of the containment hierarchy
        &#34;&#34;&#34;
        return RootWidget.root_widget

    @staticmethod
    def getTopWidget():
        return RootWidget.top_widget

    @staticmethod
    def getFocus():
        return RootWidget.top_widget.get_focus()

    @staticmethod
    def addUserEvent(newCallback: UserEventCall):

        RootWidget.userEventCallList.append(newCallback)

    # ========================================================================
    #
    #  Abstract methods follow
    #
    # ========================================================================

    def report_error(self, e):
        pass

    def confirm_quit(self) -&gt; bool:
        &#34;&#34;&#34;
        Called to give an opportunity to ask the user to confirm quitting the main event loop. If it returns
        true, sys.exit(0) is performed, otherwise nothing is done. The default implementation unconditionally
        returns true.

        Returns: True to confirm else False

        &#34;&#34;&#34;
        return True

    def defer_drawing(self) -&gt; bool:
        &#34;&#34;&#34;
        f this method returns true, pending display updates are only performed when a timer event occurs and the
        timer_event() method of the root widget returns true. Otherwise, the display is updated after every input
        event except for mouse-move events. The default implementation returns True.

        Returns: True to defer else False

        &#34;&#34;&#34;
        return True

    def timer_event(self, event):
        &#34;&#34;&#34;
        Called when a timer event occurs. See set_timer(). If it returns true, a display update is performed. The
        default implementation returns true.

        Note:
            If multiple timer events occur during a single pass through the event loop, only the most recent
            one is passed to timer_event() and the others are discarded. Also, if other types of event occur during
            the same pass through the event loop, all the other events are processed before calling timer_event(), even
            if the timer event was not the last to occur chronologically.

        Args:
            event:

        Returns:  True

        &#34;&#34;&#34;
        self.begin_frame()
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="albow.core.Widget.Widget" href="Widget.html#albow.core.Widget.Widget">Widget</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="albow.core.Shell.Shell" href="Shell.html#albow.core.Shell.Shell">Shell</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="albow.core.RootWidget.RootWidget.DOUBLE_CLICK_TIME"><code class="name">var <span class="ident">DOUBLE_CLICK_TIME</span></code></dt>
<dd>
<section class="desc"><p>Time is in milliseconds</p></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.MUSIC_END_EVENT"><code class="name">var <span class="ident">MUSIC_END_EVENT</span></code></dt>
<dd>
<section class="desc"><p>API consumer user events <strong>MUST</strong> start there events after this one</p></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.clicked_widget"><code class="name">var <span class="ident">clicked_widget</span></code></dt>
<dd>
<section class="desc"><p>Target of mouse_drag and mouse_up events</p></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.do_draw"><code class="name">var <span class="ident">do_draw</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.frame_time"><code class="name">var <span class="ident">frame_time</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.last_mouse_event"><code class="name">var <span class="ident">last_mouse_event</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.last_mouse_event_handler"><code class="name">var <span class="ident">last_mouse_event_handler</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.nextFrameDue"><code class="name">var <span class="ident">nextFrameDue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.ourTimerEvent"><code class="name">var <span class="ident">ourTimerEvent</span></code></dt>
<dd>
<section class="desc"><p>Timer event pending delivery</p></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.redraw_every_frame"><code class="name">var <span class="ident">redraw_every_frame</span></code></dt>
<dd>
<section class="desc"><p>If true, all widgets will be redrawn on every animation frame (i.e. after every call to begin_frame()). If false,
redrawing only occurs after user input events, such as mouse clicks and keystrokes, or if a widget calls
its invalidate() method. The default is false.</p></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.root_widget"><code class="name">var <span class="ident">root_widget</span></code></dt>
<dd>
<section class="desc"><p>Root of the containment hierarchy</p></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.top_widget"><code class="name">var <span class="ident">top_widget</span></code></dt>
<dd>
<section class="desc"><p>Initial dispatch target</p></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.userEventCallList"><code class="name">var <span class="ident">userEventCallList</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="albow.core.RootWidget.RootWidget.addUserEvent"><code class="name flex">
<span>def <span class="ident">addUserEvent</span></span>(<span>newCallback)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def addUserEvent(newCallback: UserEventCall):

    RootWidget.userEventCallList.append(newCallback)</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.getFocus"><code class="name flex">
<span>def <span class="ident">getFocus</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def getFocus():
    return RootWidget.top_widget.get_focus()</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.getRoot"><code class="name flex">
<span>def <span class="ident">getRoot</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns:
The root widget of the containment hierarchy</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def getRoot():
    &#34;&#34;&#34;
    Returns:  The root widget of the containment hierarchy
    &#34;&#34;&#34;
    return RootWidget.root_widget</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.getTopWidget"><code class="name flex">
<span>def <span class="ident">getTopWidget</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def getTopWidget():
    return RootWidget.top_widget</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="albow.core.RootWidget.RootWidget.begin_frame"><code class="name flex">
<span>def <span class="ident">begin_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Deprecated, use timer_event() instead.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def begin_frame(self):
    &#34;&#34;&#34;Deprecated, use timer_event() instead.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.confirm_quit"><code class="name flex">
<span>def <span class="ident">confirm_quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Called to give an opportunity to ask the user to confirm quitting the main event loop. If it returns
true, sys.exit(0) is performed, otherwise nothing is done. The default implementation unconditionally
returns true.</p>
<p>Returns: True to confirm else False</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def confirm_quit(self) -&gt; bool:
    &#34;&#34;&#34;
    Called to give an opportunity to ask the user to confirm quitting the main event loop. If it returns
    true, sys.exit(0) is performed, otherwise nothing is done. The default implementation unconditionally
    returns true.

    Returns: True to confirm else False

    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.defer_drawing"><code class="name flex">
<span>def <span class="ident">defer_drawing</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>f this method returns true, pending display updates are only performed when a timer event occurs and the
timer_event() method of the root widget returns true. Otherwise, the display is updated after every input
event except for mouse-move events. The default implementation returns True.</p>
<p>Returns: True to defer else False</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def defer_drawing(self) -&gt; bool:
    &#34;&#34;&#34;
    f this method returns true, pending display updates are only performed when a timer event occurs and the
    timer_event() method of the root widget returns true. Otherwise, the display is updated after every input
    event except for mouse-move events. The default implementation returns True.

    Returns: True to defer else False

    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.get_mouse_for"><code class="name flex">
<span>def <span class="ident">get_mouse_for</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_mouse_for(self, widget):
    last = RootWidget.last_mouse_event
    event = Event(0, last.dict)
    event.dict[&#39;local&#39;] = widget.global_to_local(event.pos)
    CoreUtilities.add_modifiers(event)
    return event</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.music_end"><code class="name flex">
<span>def <span class="ident">music_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def music_end(self):
    MusicUtilities.music_end()</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This method is called when a QUIT event is received. The default implementation first calls
confirm_quit(), and if it returns true, calls sys.exit(0).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def quit(self):
    &#34;&#34;&#34;
    This method is called when a QUIT event is received. The default implementation first calls
    confirm_quit(), and if it returns true, calls sys.exit(0).
    &#34;&#34;&#34;
    if self.confirm_quit():
        sys.exit(0)</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.report_error"><code class="name flex">
<span>def <span class="ident">report_error</span></span>(<span>self, e)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def report_error(self, e):
    pass</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Runs the main event loop. Control is retained until a QUIT event is received, whereupon the quit() method
is called.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    Runs the main event loop. Control is retained until a QUIT event is received, whereupon the quit() method
    is called.

    &#34;&#34;&#34;
    self.run_modal(None)</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.run_modal"><code class="name flex">
<span>def <span class="ident">run_modal</span></span>(<span>self, modal_widget)</span>
</code></dt>
<dd>
<section class="desc"><p>Runs a modal event loop. The widget is run as a modal dialog until its dismiss() method is called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>modal_widget</code></strong></dt>
<dd>The modal widget</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def run_modal(self, modal_widget: Widget):
    &#34;&#34;&#34;
        Runs a modal event loop. The widget is run as a modal dialog until its dismiss() method is called.
    Args:
        modal_widget:  The modal widget
    &#34;&#34;&#34;
    is_modal = modal_widget is not None
    modal_widget = modal_widget or self
    relative_pause = False
    relative_warmup = 0

    was_modal = None
    try:
        RootWidget.old_top_widget = RootWidget.top_widget
        RootWidget.top_widget = modal_widget
        was_modal = modal_widget.is_modal

        modal_widget.is_modal = True
        modal_widget.modal_result = None
        if not modal_widget.focus_switch:

            modal_widget.tab_to_first()

        num_clicks = 0
        last_click_time = 0
        self.do_draw = True
        use_sleep = self._use_sleep
        while modal_widget.modal_result is None:
            # print &#34;RootWidget: frame_time =&#34;, self.frame_time ###
            #
            # Python 3 update
            #
            # defer_drawing = self.frame_time &lt;&gt; 0.0 and modal_widget.defer_drawing()
            defer_drawing = self.frame_time != 0.0 and modal_widget.defer_drawing()
            try:
                if not is_modal:
                    if RootWidget.ourTimerEvent:
                        if not use_sleep and defer_drawing:
                            Scheduler.make_scheduled_calls()
                        CoreUtilities.add_modifiers(RootWidget.ourTimerEvent)
                        if RootWidget.last_mouse_event:
                            RootWidget.ourTimerEvent.dict[&#39;pos&#39;] = RootWidget.last_mouse_event.pos
                            RootWidget.ourTimerEvent.dict[&#39;local&#39;] = RootWidget.last_mouse_event.local
                        if RootWidget.last_mouse_event_handler:
                            RootWidget.last_mouse_event_handler.setup_cursor(RootWidget.ourTimerEvent)
                        self.do_draw = self.timer_event(RootWidget.ourTimerEvent)
                        RootWidget.ourTimerEvent = None
                    else:
                        if defer_drawing:
                            # print &#34;RootWidget: Clearing do_draw because of defer_drawing&#34; ###
                            self.do_draw = False
                # print &#34;RootWidget: do_draw =&#34;, self.do_draw ###
                if self.do_draw:
                    if self.is_gl:
                        # self.gl_clear()
                        # self.gl_draw_all(self, (0, 0))
                        # GL.glFlush()
                        gl_surface = self.gl_surface
                        gl_surface.gl_clear(self.bg_color)
                        self.gl_draw_all(gl_surface)
                        gl_surface.gl_flush()
                    else:
                        self.draw_all(self.surface)
                    self.do_draw = False
                    # tb1 = timestamp() ###
                    pygame.display.flip()
                # tb2 = timestamp() ###
                # print &#34;RootWidget: Flip block  %5d&#34; % (tb2 - tb1) ###
                in_relative_mode = bool(modal_widget.relative_mode())
                grab = in_relative_mode and not relative_pause
                # if grab &lt;&gt; get_grab():
                if grab != get_grab():
                    set_grab(grab)
                    set_mouse_visible(not grab)
                    relative_warmup = 3     # Ignore spurious deltas on entering relative mode
                    # tb1 = timestamp() ###
                    # print &#34;RootWidget: use_sleep =&#34;, use_sleep, &#34;defer_drawing =&#34;, defer_drawing ###
                if use_sleep and defer_drawing:
                    #  print &#34;RootWidget: Handling timing&#34; ###
                    time_now = Scheduler.timestamp()
                    #  print &#34;RootWidget: Time is now&#34;, time_now ###
                    if RootWidget.nextFrameDue &lt; time_now:
                        #  print &#34;RootWidget: Adjusting next frame due time to time now&#34; ###
                        RootWidget.nextFrameDue = time_now
                        #  print &#34;RootWidget: Waiting for next frame due at&#34;, next_frame_due ###
                    while 1:
                        sleep_time = Scheduler.make_due_calls(time_now, RootWidget.nextFrameDue)
                        if sleep_time &lt;= 0.0:
                            break
                        # print &#34;RootWidget: Sleeping for&#34;, sleep_time ###
                        sleep(sleep_time / 1000.0)
                        time_now = Scheduler.timestamp()
                    RootWidget.nextFrameDue += self.frame_time
                    # print &#34;RootWidget: Next frame now due at&#34;, next_frame_due ###
                    #
                    # Pygame 1.9 update
                    #
                    # timer_event = Event(USEREVENT, time = time_now)
                    RootWidget.ourTimerEvent = Event(USEREVENT)
                    RootWidget.ourTimerEvent.dict[&#39;time&#39;] = time_now

                    events = []
                else:
                    events = [pygame.event.wait()]
                # tb2 = timestamp() ###
                # tb = tb2 - tb1 ###
                # if tb: ###
                # print &#34;RootWidget: Event block %5d&#34; % tb ###
                events.extend(pygame.event.get())
                for event in events:
                    t = Scheduler.timestamp()
                    event.dict[&#39;time&#39;] = t
                    event.dict[&#39;local&#39;] = getattr(event, &#39;pos&#39;, (0, 0))
                    eventType = event.type
                    if eventType == QUIT:
                        self.quit()
                    elif eventType == MOUSEBUTTONDOWN:
                        # print &#34;RootWidget: MOUSEBUTTONDOWN: setting do_draw&#34; ###
                        self.do_draw = True
                        if t - last_click_time &lt;= RootWidget.DOUBLE_CLICK_TIME:
                            num_clicks += 1
                        else:
                            num_clicks = 1
                        last_click_time = t
                        event.dict[&#39;num_clicks&#39;] = num_clicks
                        CoreUtilities.add_modifiers(event)
                        RootWidget.last_mouse_event = event
                        if in_relative_mode:
                            event.dict[&#39;local&#39;] = (0, 0)
                            if relative_pause:
                                relative_pause = False
                            else:
                                #  modal_widget.dispatch_key(&#39;mouse_down&#39;, event)
                                mouse_widget = modal_widget.get_focus()
                                RootWidget.clicked_widget = mouse_widget
                                RootWidget.last_mouse_event_handler = mouse_widget
                                mouse_widget.handle_event(&#39;mouse_down&#39;, event)
                        else:
                            mouse_widget = self.find_widget(event.pos)
                            if not mouse_widget.is_inside(modal_widget):
                                mouse_widget = modal_widget
                            RootWidget.clicked_widget = mouse_widget
                            RootWidget.last_mouse_event_handler = mouse_widget
                            mouse_widget.notify_attention_loss()
                            mouse_widget.handle_mouse(&#39;mouse_down&#39;, event)
                    elif eventType == MOUSEMOTION:
                        CoreUtilities.add_modifiers(event)
                        RootWidget.last_mouse_event = event
                        if in_relative_mode:
                            event.dict[&#39;local&#39;] = (0, 0)
                            if not relative_pause:
                                if relative_warmup:
                                    relative_warmup -= 1
                                else:
                                    #  modal_widget.dispatch_key(&#39;mouse_delta&#39;, event)
                                    mouse_widget = RootWidget.clicked_widget or modal_widget.get_focus()
                                    RootWidget.last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_event(&#39;mouse_delta&#39;, event)
                        else:
                            mouse_widget = self.find_widget(event.pos)   # Do this in else branch?
                            if RootWidget.clicked_widget:
                                RootWidget.last_mouse_event_handler = mouse_widget  # Should this be clicked_widget?
                                RootWidget.clicked_widget.handle_mouse(&#39;mouse_drag&#39;, event)
                            else:
                                if not mouse_widget.is_inside(modal_widget):
                                    mouse_widget = modal_widget
                                RootWidget.last_mouse_event_handler = mouse_widget
                                mouse_widget.handle_mouse(&#39;mouse_move&#39;, event)
                    elif eventType == MOUSEBUTTONUP:
                        CoreUtilities.add_modifiers(event)
                        RootWidget.last_mouse_event = event
                        self.do_draw = True
                        if in_relative_mode:
                            event.dict[&#39;local&#39;] = (0, 0)
                            if not relative_pause:

                                if RootWidget.clicked_widget:
                                    mouse_widget = RootWidget.clicked_widget
                                    RootWidget.clicked_widget = None
                                else:
                                    mouse_widget = modal_widget.get_focus()
                                RootWidget.last_mouse_event_handler = mouse_widget
                                mouse_widget.handle_event(&#39;mouse_up&#39;, event)
                        else:
                            if RootWidget.clicked_widget:
                                RootWidget.last_mouse_event_handler = RootWidget.clicked_widget
                                RootWidget.clicked_widget = None
                                RootWidget.last_mouse_event_handler.handle_mouse(&#39;mouse_up&#39;, event)
                    elif eventType == KEYDOWN:
                        key = event.key
                        if key == K_ESCAPE and in_relative_mode and \
                                event.mod &amp; KMOD_CTRL and event.mod &amp; KMOD_SHIFT:
                            relative_pause = True
                        elif relative_pause:
                            relative_pause = False
                        else:
                            CoreUtilities.set_modifier(key, True)
                            self.do_draw = True
                            self.send_key(modal_widget, &#39;key_down&#39;, event)
                            if RootWidget.last_mouse_event_handler:
                                event.dict[&#39;pos&#39;] = RootWidget.last_mouse_event.pos
                                event.dict[&#39;local&#39;] = RootWidget.last_mouse_event.local
                                RootWidget.last_mouse_event_handler.setup_cursor(event)
                    elif eventType == KEYUP:
                        key = event.key
                        CoreUtilities.set_modifier(key, False)
                        self.do_draw = True
                        self.send_key(modal_widget, &#39;key_up&#39;, event)
                        if RootWidget.last_mouse_event_handler:
                            event.dict[&#39;pos&#39;] = RootWidget.last_mouse_event.pos
                            event.dict[&#39;local&#39;] = RootWidget.last_mouse_event.local
                            RootWidget.last_mouse_event_handler.setup_cursor(event)
                    elif eventType == RootWidget.MUSIC_END_EVENT:
                        self.music_end()
                    elif eventType == USEREVENT:
                        if defer_drawing and not use_sleep:
                            RootWidget.ourTimerEvent = event
                    else:
                        #
                        # Maybe someone has registered some user events handler
                        #
                        for cb in RootWidget.userEventCallList:
                            if cb.userEvent == eventType:
                                self.logger.debug(f&#34;API User eventType: {eventType}&#34;)
                                cb.func(event)

            except CancelException:
                pass
            #
            # Python 3 update
            #
            # except ApplicationError, e:
            except ApplicationException as e:
                self.report_error(e)
    finally:
        modal_widget.is_modal = was_modal
        RootWidget.top_widget = RootWidget.old_top_widget
    RootWidget.clicked_widget = None</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.send_key"><code class="name flex">
<span>def <span class="ident">send_key</span></span>(<span>self, widget, name, event)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def send_key(self, widget, name, event):
    CoreUtilities.add_modifiers(event)
    widget.dispatch_key(name, event)</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.set_timer"><code class="name flex">
<span>def <span class="ident">set_timer</span></span>(<span>self, ms)</span>
</code></dt>
<dd>
<section class="desc"><p>Arranges for timer events to be generated every interval milliseconds. See timer_event().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ms</code></strong></dt>
<dd>The timer interval in milli-seconds</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_timer(self, ms):
    &#34;&#34;&#34;
    Arranges for timer events to be generated every interval milliseconds. See timer_event().

    Args:
        ms:  The timer interval in milli-seconds

    &#34;&#34;&#34;
    self.frame_time = ms
    if not self._use_sleep:
        set_pygame_timer(USEREVENT, max(1, int(round(ms))))</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.timer_event"><code class="name flex">
<span>def <span class="ident">timer_event</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when a timer event occurs. See set_timer(). If it returns true, a display update is performed. The
default implementation returns true.</p>
<h2 id="note">Note</h2>
<p>If multiple timer events occur during a single pass through the event loop, only the most recent
one is passed to timer_event() and the others are discarded. Also, if other types of event occur during
the same pass through the event loop, all the other events are processed before calling timer_event(), even
if the timer event was not the last to occur chronologically.</p>
<h2 id="args">Args</h2>
<dl>
<dt>event:</dt>
<dt><strong><code>Returns</code></strong> :&ensp; <code>True</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def timer_event(self, event):
    &#34;&#34;&#34;
    Called when a timer event occurs. See set_timer(). If it returns true, a display update is performed. The
    default implementation returns true.

    Note:
        If multiple timer events occur during a single pass through the event loop, only the most recent
        one is passed to timer_event() and the others are discarded. Also, if other types of event occur during
        the same pass through the event loop, all the other events are processed before calling timer_event(), even
        if the timer event was not the last to occur chronologically.

    Args:
        event:

    Returns:  True

    &#34;&#34;&#34;
    self.begin_frame()
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="albow.core.Widget.Widget" href="Widget.html#albow.core.Widget.Widget">Widget</a></b></code>:
<ul class="hlist">
<li><code><a title="albow.core.Widget.Widget.add" href="Widget.html#albow.core.Widget.Widget.add">add</a></code></li>
<li><code><a title="albow.core.Widget.Widget.add_anchor" href="Widget.html#albow.core.Widget.Widget.add_anchor">add_anchor</a></code></li>
<li><code><a title="albow.core.Widget.Widget.add_centered" href="Widget.html#albow.core.Widget.Widget.add_centered">add_centered</a></code></li>
<li><code><a title="albow.core.Widget.Widget.anchor" href="Widget.html#albow.core.Widget.Widget.anchor">anchor</a></code></li>
<li><code><a title="albow.core.Widget.Widget.attention_lost" href="Widget.html#albow.core.Widget.Widget.attention_lost">attention_lost</a></code></li>
<li><code><a title="albow.core.Widget.Widget.augment_mouse_event" href="Widget.html#albow.core.Widget.Widget.augment_mouse_event">augment_mouse_event</a></code></li>
<li><code><a title="albow.core.Widget.Widget.bg_color" href="Widget.html#albow.core.Widget.Widget.bg_color">bg_color</a></code></li>
<li><code><a title="albow.core.Widget.Widget.bg_image" href="Widget.html#albow.core.Widget.Widget.bg_image">bg_image</a></code></li>
<li><code><a title="albow.core.Widget.Widget.border_color" href="Widget.html#albow.core.Widget.Widget.border_color">border_color</a></code></li>
<li><code><a title="albow.core.Widget.Widget.border_width" href="Widget.html#albow.core.Widget.Widget.border_width">border_width</a></code></li>
<li><code><a title="albow.core.Widget.Widget.call_handler" href="Widget.html#albow.core.Widget.Widget.call_handler">call_handler</a></code></li>
<li><code><a title="albow.core.Widget.Widget.call_parent_handler" href="Widget.html#albow.core.Widget.Widget.call_parent_handler">call_parent_handler</a></code></li>
<li><code><a title="albow.core.Widget.Widget.dismiss" href="Widget.html#albow.core.Widget.Widget.dismiss">dismiss</a></code></li>
<li><code><a title="albow.core.Widget.Widget.draw" href="Widget.html#albow.core.Widget.Widget.draw">draw</a></code></li>
<li><code><a title="albow.core.Widget.Widget.draw_over" href="Widget.html#albow.core.Widget.Widget.draw_over">draw_over</a></code></li>
<li><code><a title="albow.core.Widget.Widget.fg_color" href="Widget.html#albow.core.Widget.Widget.fg_color">fg_color</a></code></li>
<li><code><a title="albow.core.Widget.Widget.focus" href="Widget.html#albow.core.Widget.Widget.focus">focus</a></code></li>
<li><code><a title="albow.core.Widget.Widget.focus_switch" href="Widget.html#albow.core.Widget.Widget.focus_switch">focus_switch</a></code></li>
<li><code><a title="albow.core.Widget.Widget.font" href="Widget.html#albow.core.Widget.Widget.font">font</a></code></li>
<li><code><a title="albow.core.Widget.Widget.get_cursor" href="Widget.html#albow.core.Widget.Widget.get_cursor">get_cursor</a></code></li>
<li><code><a title="albow.core.Widget.Widget.get_focus" href="Widget.html#albow.core.Widget.Widget.get_focus">get_focus</a></code></li>
<li><code><a title="albow.core.Widget.Widget.get_margin_rect" href="Widget.html#albow.core.Widget.Widget.get_margin_rect">get_margin_rect</a></code></li>
<li><code><a title="albow.core.Widget.Widget.get_root" href="Widget.html#albow.core.Widget.Widget.get_root">get_root</a></code></li>
<li><code><a title="albow.core.Widget.Widget.get_top_widget" href="Widget.html#albow.core.Widget.Widget.get_top_widget">get_top_widget</a></code></li>
<li><code><a title="albow.core.Widget.Widget.get_visible" href="Widget.html#albow.core.Widget.Widget.get_visible">get_visible</a></code></li>
<li><code><a title="albow.core.Widget.Widget.global_to_local" href="Widget.html#albow.core.Widget.Widget.global_to_local">global_to_local</a></code></li>
<li><code><a title="albow.core.Widget.Widget.has_focus" href="Widget.html#albow.core.Widget.Widget.has_focus">has_focus</a></code></li>
<li><code><a title="albow.core.Widget.Widget.inherited" href="Widget.html#albow.core.Widget.Widget.inherited">inherited</a></code></li>
<li><code><a title="albow.core.Widget.Widget.invalidate" href="Widget.html#albow.core.Widget.Widget.invalidate">invalidate</a></code></li>
<li><code><a title="albow.core.Widget.Widget.is_gl_container" href="Widget.html#albow.core.Widget.Widget.is_gl_container">is_gl_container</a></code></li>
<li><code><a title="albow.core.Widget.Widget.key_down" href="Widget.html#albow.core.Widget.Widget.key_down">key_down</a></code></li>
<li><code><a title="albow.core.Widget.Widget.key_up" href="Widget.html#albow.core.Widget.Widget.key_up">key_up</a></code></li>
<li><code><a title="albow.core.Widget.Widget.local_to_global" href="Widget.html#albow.core.Widget.Widget.local_to_global">local_to_global</a></code></li>
<li><code><a title="albow.core.Widget.Widget.margin" href="Widget.html#albow.core.Widget.Widget.margin">margin</a></code></li>
<li><code><a title="albow.core.Widget.Widget.menu_bar" href="Widget.html#albow.core.Widget.Widget.menu_bar">menu_bar</a></code></li>
<li><code><a title="albow.core.Widget.Widget.parent" href="Widget.html#albow.core.Widget.Widget.parent">parent</a></code></li>
<li><code><a title="albow.core.Widget.Widget.parent_resized" href="Widget.html#albow.core.Widget.Widget.parent_resized">parent_resized</a></code></li>
<li><code><a title="albow.core.Widget.Widget.present" href="Widget.html#albow.core.Widget.Widget.present">present</a></code></li>
<li><code><a title="albow.core.Widget.Widget.rect" href="Widget.html#albow.core.Widget.Widget.rect">rect</a></code></li>
<li><code><a title="albow.core.Widget.Widget.relative_mode" href="Widget.html#albow.core.Widget.Widget.relative_mode">relative_mode</a></code></li>
<li><code><a title="albow.core.Widget.Widget.remove" href="Widget.html#albow.core.Widget.Widget.remove">remove</a></code></li>
<li><code><a title="albow.core.Widget.Widget.remove_anchor" href="Widget.html#albow.core.Widget.Widget.remove_anchor">remove_anchor</a></code></li>
<li><code><a title="albow.core.Widget.Widget.resized" href="Widget.html#albow.core.Widget.Widget.resized">resized</a></code></li>
<li><code><a title="albow.core.Widget.Widget.scale_bg" href="Widget.html#albow.core.Widget.Widget.scale_bg">scale_bg</a></code></li>
<li><code><a title="albow.core.Widget.Widget.sel_color" href="Widget.html#albow.core.Widget.Widget.sel_color">sel_color</a></code></li>
<li><code><a title="albow.core.Widget.Widget.set_parent" href="Widget.html#albow.core.Widget.Widget.set_parent">set_parent</a></code></li>
<li><code><a title="albow.core.Widget.Widget.set_size_for_text" href="Widget.html#albow.core.Widget.Widget.set_size_for_text">set_size_for_text</a></code></li>
<li><code><a title="albow.core.Widget.Widget.tab_stop" href="Widget.html#albow.core.Widget.Widget.tab_stop">tab_stop</a></code></li>
<li><code><a title="albow.core.Widget.Widget.visible" href="Widget.html#albow.core.Widget.Widget.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="albow.core" href="index.html">albow.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="albow.core.RootWidget.RootWidget" href="#albow.core.RootWidget.RootWidget">RootWidget</a></code></h4>
<ul class="">
<li><code><a title="albow.core.RootWidget.RootWidget.DOUBLE_CLICK_TIME" href="#albow.core.RootWidget.RootWidget.DOUBLE_CLICK_TIME">DOUBLE_CLICK_TIME</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.MUSIC_END_EVENT" href="#albow.core.RootWidget.RootWidget.MUSIC_END_EVENT">MUSIC_END_EVENT</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.addUserEvent" href="#albow.core.RootWidget.RootWidget.addUserEvent">addUserEvent</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.begin_frame" href="#albow.core.RootWidget.RootWidget.begin_frame">begin_frame</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.clicked_widget" href="#albow.core.RootWidget.RootWidget.clicked_widget">clicked_widget</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.confirm_quit" href="#albow.core.RootWidget.RootWidget.confirm_quit">confirm_quit</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.defer_drawing" href="#albow.core.RootWidget.RootWidget.defer_drawing">defer_drawing</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.do_draw" href="#albow.core.RootWidget.RootWidget.do_draw">do_draw</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.frame_time" href="#albow.core.RootWidget.RootWidget.frame_time">frame_time</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.getFocus" href="#albow.core.RootWidget.RootWidget.getFocus">getFocus</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.getRoot" href="#albow.core.RootWidget.RootWidget.getRoot">getRoot</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.getTopWidget" href="#albow.core.RootWidget.RootWidget.getTopWidget">getTopWidget</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.get_mouse_for" href="#albow.core.RootWidget.RootWidget.get_mouse_for">get_mouse_for</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.last_mouse_event" href="#albow.core.RootWidget.RootWidget.last_mouse_event">last_mouse_event</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.last_mouse_event_handler" href="#albow.core.RootWidget.RootWidget.last_mouse_event_handler">last_mouse_event_handler</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.music_end" href="#albow.core.RootWidget.RootWidget.music_end">music_end</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.nextFrameDue" href="#albow.core.RootWidget.RootWidget.nextFrameDue">nextFrameDue</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.ourTimerEvent" href="#albow.core.RootWidget.RootWidget.ourTimerEvent">ourTimerEvent</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.quit" href="#albow.core.RootWidget.RootWidget.quit">quit</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.redraw_every_frame" href="#albow.core.RootWidget.RootWidget.redraw_every_frame">redraw_every_frame</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.report_error" href="#albow.core.RootWidget.RootWidget.report_error">report_error</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.root_widget" href="#albow.core.RootWidget.RootWidget.root_widget">root_widget</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.run" href="#albow.core.RootWidget.RootWidget.run">run</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.run_modal" href="#albow.core.RootWidget.RootWidget.run_modal">run_modal</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.send_key" href="#albow.core.RootWidget.RootWidget.send_key">send_key</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.set_timer" href="#albow.core.RootWidget.RootWidget.set_timer">set_timer</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.timer_event" href="#albow.core.RootWidget.RootWidget.timer_event">timer_event</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.top_widget" href="#albow.core.RootWidget.RootWidget.top_widget">top_widget</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.userEventCallList" href="#albow.core.RootWidget.RootWidget.userEventCallList">userEventCallList</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>