<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.0" />
<title>albow.core.ResourceUtility API documentation</title>
<meta name="description" content="The resource module exports some utility functions for finding, loading and caching various types of
resources.
By default, resource files are looked â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>albow.core.ResourceUtility</code></h1>
</header>
<section id="section-intro">
<p>The resource module exports some utility functions for finding, loading and caching various types of
resources.
By default, resource files are looked for in a directory named <em>Resources</em> alongside the
.py file of the program's main module.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>But that can be changed by assigning to the <code>resource_dir</code> module variable.</p>
</div>
<p>Resource names are specified in a platform-independent manner using a series of pathname components. Specific
resource types are looked for by default in subdirectories of the resources directory as follows:</p>
<table>
<thead>
<tr>
<th>Types</th>
<th></th>
<th align="right">Location</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fonts</td>
<td></td>
<td align="right"><em>resources</em>/fonts</td>
</tr>
<tr>
<td>Sounds</td>
<td></td>
<td align="right"><em>resources</em>/sounds</td>
</tr>
<tr>
<td>Text</td>
<td></td>
<td align="right"><em>resources</em>/text</td>
</tr>
<tr>
<td>Cursors</td>
<td></td>
<td align="right"><em>resources</em>/cursors</td>
</tr>
<tr>
<td>Music</td>
<td></td>
<td align="right"><em>resources</em>/music</td>
</tr>
</tbody>
</table>
<p>The subdirectory can in some cases be overridden using the <code>prefix</code> parameter to the relevant resource-loading
function.
Each type of resource has a cache. The first time a resource with a given name is requested, it is
loaded and placed in the cache.
Subsequent requests for the same name will return the cached object.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
The resource module exports some utility functions for finding, loading and caching various types of
resources.  By default, resource files are looked for in a directory named _Resources_ alongside the
.py file of the program&#39;s main module.

.. TODO::
    But that can be changed by assigning to the `resource_dir` module variable.

Resource names are specified in a platform-independent manner using a series of pathname components. Specific
resource types are looked for by default in subdirectories of the resources directory as follows:


| Types   |      |            Location |
| ------- | ---- | ------------------: |
| Fonts   |      |   *resources*/fonts |
| Sounds  |      |  *resources*/sounds |
| Text    |      |    *resources*/text |
| Cursors |      | *resources*/cursors |
| Music   |      |   *resources*/music |


The subdirectory can in some cases be overridden using the `prefix` parameter to the relevant resource-loading
function.  Each type of resource has a cache. The first time a resource with a given name is requested, it is
loaded and placed in the cache.  Subsequent requests for the same name will return the cached object.


&#34;&#34;&#34;
import os
import sys
import logging

import pygame
from pygame.locals import RLEACCEL

from albow.core.DummySound import DummySound

DEFAULT_SOUND_DIRECTORY   = &#34;sounds&#34;
DEFAULT_CURSORS_DIRECTORY = &#34;cursors&#34;
DEFAULT_IMAGES_DIRECTORY  = &#34;images&#34;
DEFAULT_FONTS_DIRECTORY   = &#34;fonts&#34;
DEFAULT_TEXT_DIRECTORY    = &#34;text&#34;

optimize_images   = True
&#34;&#34;&#34;
If `True`, images loaded with `get_image()` will have `convert_alpha()` called on them by default. Defaults to `True`.
&#34;&#34;&#34;
run_length_encode = False

DEFAULT_RESOURCE_DIRECTORY_NAMES = [&#34;Resources&#34;, &#34;resources&#34;]

image_cache  = {}
font_cache   = {}
sound_cache  = {}
text_cache   = {}
cursor_cache = {}

dummy_sound = DummySound()

ourLogger = logging.getLogger(__name__)


class ResourceUtility:
    &#34;&#34;&#34;
    Static class housing shortcut methods to quickly access system resources like

    - sounds
    - cursors
    - fonts
    - images
    - resource directories

    .. Note::
        Make unit tests for sound and cursor APIs since they are not currently demo&#39;ed
    &#34;&#34;&#34;

    @staticmethod
    def find_resource_dir():

        directory = sys.path[0]

        while True:
            for name in DEFAULT_RESOURCE_DIRECTORY_NAMES:
                path = os.path.join(directory, name)
                if os.path.exists(path):
                    return path
            parent = os.path.dirname(directory)
            if parent == directory:
                raise SystemError(&#34;albow: Unable to find Resources directory&#34;)
            directory = parent

    @staticmethod
    def resource_exists(*names, **kwds) -&gt; bool:
        &#34;&#34;&#34;
        Returns true if a resource exists with the given pathname components.

        Args:
            *names:

            **kwds:

        Returns:  `True` if it does, else `False`

        &#34;&#34;&#34;
        return os.path.exists(ResourceUtility._resource_path(&#34;&#34;, names, **kwds))

    @staticmethod
    def get_image(*names, **kwds):
        &#34;&#34;&#34;
        Loads the specified image from the images directory or returns it from the cache.

        .. WARNING::
            For some of the options to work correctly, you must have initialized the PyGame screen before calling get_image().
        Args:
            *names:

            **kwds:

        Returns:

        &#34;&#34;&#34;
        prefix = kwds.pop(&#39;prefix&#39;, &#34;%s&#34; % DEFAULT_IMAGES_DIRECTORY)
        path = ResourceUtility._resource_path(prefix, names)
        return ResourceUtility._get_image(path, **kwds)

    @staticmethod
    def get_font(size, *names, **kwds):
        &#34;&#34;&#34;
        Loads the specified font or returns it from the cache.

        Args:
            size:   This size font to load

            *names:

            **kwds:

        Returns:    A pygame font

        &#34;&#34;&#34;
        path = ResourceUtility._resource_path(&#34;%s&#34; % DEFAULT_FONTS_DIRECTORY, names, **kwds)
        key = (path, size)
        font = font_cache.get(key)
        if not font:
            try:
                font = pygame.font.Font(path, size)
            #
            # Python 3 update
            #
            # except IOError, e:
            except IOError as e:
                raise e.__class__(&#34;%s: %s&#34; % (e, path))
            font_cache[key] = font
        return font

    @staticmethod
    def get_text(*names, **kwds):
        &#34;&#34;&#34;
        Loads the contents of a text file as a string or returns it from the cache. The file is opened in
        universal newlines mode.

        Args:
            *names:
            **kwds:

        Returns:

        &#34;&#34;&#34;
        path = ResourceUtility._resource_path(&#34;%s&#34; % DEFAULT_TEXT_DIRECTORY, names, **kwds)
        text = text_cache.get(path)
        if text is None:
            text = open(path, &#34;rU&#34;).read()
            text_cache[path] = text
        return text

    @staticmethod
    def resource_path(*names, **kwds) -&gt; str:
        &#34;&#34;&#34;
        Constructs a resource pathname from the given pathname components.

        Args:
            *names:

            **kwds:

        Returns:    The resource path

        &#34;&#34;&#34;
        return ResourceUtility._resource_path(&#34;&#34;, names, **kwds)

    @staticmethod
    def get_sound(*names, **kwds):
        &#34;&#34;&#34;
        Loads the specified sound or returns it from the cache.

        If the sound is unable to be loaded for any reason, a warning message is printed and a dummy sound object
        with no-op methods is returned. This allows an application to continue without sound in an environment
        where sound support is not available.

        Args:
            *names:  Sound file name

            **kwds:

        Returns:

        &#34;&#34;&#34;
        path = ResourceUtility._resource_path(&#34;%s&#34; % DEFAULT_SOUND_DIRECTORY, names, **kwds)

        return ResourceUtility.load_sound(path)

    @staticmethod
    def load_sound(path) -&gt; &#39;Sound&#39;:
        &#34;&#34;&#34;
        Loads a sound from the file specified by path, or returns it from the cache. Like `get_sound()`,
        returns a dummy sound object if the sound cannot be loaded.
        
        Args:
            path:  Fully qualified path

        Returns: A pygame sound object

        &#34;&#34;&#34;
        if sound_cache is None:
            return dummy_sound
        sound = sound_cache.get(path)
        if not sound:
            try:
                from pygame.mixer import Sound
            #
            # Python 3 update
            #
            # except ImportError, e:
            except ImportError as e:
                ResourceUtility.no_sound(e)
                return dummy_sound
            try:
                sound = Sound(path)
            #
            # Python 3 update
            #
            # except pygame.error, e:
            except pygame.error as e:
                ResourceUtility.missing_sound(e, path)
                return dummy_sound
            sound_cache[path] = sound

        return sound

    @staticmethod
    def no_sound(e):
        &#34;&#34;&#34;
        Clear the sound cache as a side-effect

        :param e: Exception to log
        :return:
        &#34;&#34;&#34;
        global sound_cache

        ourLogger.error(&#34;albow.resource.get_sound: %s&#34;, e)
        ourLogger.error(&#34;albow.resource.get_sound: Sound not available, continuing without it&#34;)

        sound_cache = None

    @staticmethod
    def missing_sound(e, name):
        &#34;&#34;&#34;
        Log an error message on a missing sound

        :param e: The exception
        :param name: This name of the missing sound
        :return:
        &#34;&#34;&#34;
        ourLogger.error(&#34;albow.resource.get_sound: %s: %s&#34;, name, e)

    @staticmethod
    def get_cursor(*names, **kwds):
        &#34;&#34;&#34;
        Get a cursor out of the cache,  Else load it and cache it

        :param names:
        :param kwds:
        :return:
        &#34;&#34;&#34;

        path = ResourceUtility._resource_path(&#34;%s&#34; % DEFAULT_CURSORS_DIRECTORY, names, **kwds)
        cursor = cursor_cache.get(path)
        if cursor is None:
            cursor = ResourceUtility.load_cursor(path)
            cursor_cache[path] = cursor
        return cursor

    @staticmethod
    def load_cursor(path):
        &#34;&#34;&#34;
        Loads a cursor from an image file or returns it from the cache. The cursor is returned as a tuple of
        arguments suitable for passing to the PyGame function `set_cursor()`.

        .. IMPORTANT::
            The image must be no larger than 16x16 pixels and should consist only of the colours black (0, 0, 0),
            white (255, 255, 255), blue (0, 0, 255) and cyan (0, 255, 255).  Blue and cyan are used to indicate the
            position of the hotspot, with blue if the hotspot is over a black or transparent pixel, and cyan if it is
            over a white pixel.  The hotspot defaults to the top left corner.  If the image has an alpha channel, it
            should consist of fully opaque or fully transparent pixels.

        Args:
            path:  A fully qualified path the the image file

        Returns:

        &#34;&#34;&#34;
        image = ResourceUtility._get_image(path)
        width, height = image.get_size()
        hot = (0, 0)
        data = []
        mask = []
        rowbytes = (width + 7) // 8
        #
        # Python 3 update
        #
        # xr = xrange(width)
        # yr = xrange(height)
        xr = range(width)
        yr = range(height)

        for y in yr:
            bit = 0x80
            db = mb = 0
            for x in xr:
                r, g, b, a = image.get_at((x, y))
                if a &gt;= 128:
                    mb |= bit
                    if r + g + b &lt; 383:
                        db |= bit
                if r == 0 and b == 255:
                    hot = (x, y)
                bit &gt;&gt;= 1
                if not bit:
                    data.append(db)
                    mask.append(mb)
                    db = mb = 0
                    bit = 0x80
            # if bit &lt;&gt; 0x80:
            if bit != 0x80:
                data.append(db)
                mask.append(mb)
        return (8 * rowbytes, height), hot, data, mask

    @staticmethod
    def _resource_path(default_prefix, names, prefix=&#34;&#34;) -&gt; str:

        return os.path.join(ResourceUtility.find_resource_dir(), prefix or default_prefix, *names)

    @staticmethod
    def _get_image(path, border=0, optimize=optimize_images, noalpha=False, rle=run_length_encode):
        &#34;&#34;&#34;
        Loads the specified image from the images directory or returns it from the cache.

        Args:
            path:

            border: If border is specified, a border of that number of pixels is stripped from around the
            image (making it 2 * border pixels smaller in each direction).

            optimize: If optimize is true, convert_alpha() is called on the image.

            noalpha: If noalpha is true, any alpha channel is stripped from the image.

            rle:    If rle is true, the image is run-length encoded to improve blitting speed.

        Returns:  The specified image from the images directory or returns it from the cache
        &#34;&#34;&#34;
        image = image_cache.get(path)
        if not image:
            image = pygame.image.load(path)
            if noalpha:
                image = image.convert(24)
            elif optimize:
                image = image.convert_alpha()
            if rle:
                image.set_alpha(255, RLEACCEL)
            if border:
                w, h = image.get_size()
                b = border
                d = 2 * border
                image = image.subsurface(b, b, w - d, h - d)
            image_cache[path] = image
        return image</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="albow.core.ResourceUtility.optimize_images"><code class="name">var <span class="ident">optimize_images</span></code></dt>
<dd>
<section class="desc"><p>If <code>True</code>, images loaded with <code>get_image()</code> will have <code>convert_alpha()</code> called on them by default. Defaults to <code>True</code>.</p></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="albow.core.ResourceUtility.ResourceUtility"><code class="flex name class">
<span>class <span class="ident">ResourceUtility</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Static class housing shortcut methods to quickly access system resources like</p>
<ul>
<li>sounds</li>
<li>cursors</li>
<li>fonts</li>
<li>images</li>
<li>resource directories</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make unit tests for sound and cursor APIs since they are not currently demo'ed</p>
</div></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ResourceUtility:
    &#34;&#34;&#34;
    Static class housing shortcut methods to quickly access system resources like

    - sounds
    - cursors
    - fonts
    - images
    - resource directories

    .. Note::
        Make unit tests for sound and cursor APIs since they are not currently demo&#39;ed
    &#34;&#34;&#34;

    @staticmethod
    def find_resource_dir():

        directory = sys.path[0]

        while True:
            for name in DEFAULT_RESOURCE_DIRECTORY_NAMES:
                path = os.path.join(directory, name)
                if os.path.exists(path):
                    return path
            parent = os.path.dirname(directory)
            if parent == directory:
                raise SystemError(&#34;albow: Unable to find Resources directory&#34;)
            directory = parent

    @staticmethod
    def resource_exists(*names, **kwds) -&gt; bool:
        &#34;&#34;&#34;
        Returns true if a resource exists with the given pathname components.

        Args:
            *names:

            **kwds:

        Returns:  `True` if it does, else `False`

        &#34;&#34;&#34;
        return os.path.exists(ResourceUtility._resource_path(&#34;&#34;, names, **kwds))

    @staticmethod
    def get_image(*names, **kwds):
        &#34;&#34;&#34;
        Loads the specified image from the images directory or returns it from the cache.

        .. WARNING::
            For some of the options to work correctly, you must have initialized the PyGame screen before calling get_image().
        Args:
            *names:

            **kwds:

        Returns:

        &#34;&#34;&#34;
        prefix = kwds.pop(&#39;prefix&#39;, &#34;%s&#34; % DEFAULT_IMAGES_DIRECTORY)
        path = ResourceUtility._resource_path(prefix, names)
        return ResourceUtility._get_image(path, **kwds)

    @staticmethod
    def get_font(size, *names, **kwds):
        &#34;&#34;&#34;
        Loads the specified font or returns it from the cache.

        Args:
            size:   This size font to load

            *names:

            **kwds:

        Returns:    A pygame font

        &#34;&#34;&#34;
        path = ResourceUtility._resource_path(&#34;%s&#34; % DEFAULT_FONTS_DIRECTORY, names, **kwds)
        key = (path, size)
        font = font_cache.get(key)
        if not font:
            try:
                font = pygame.font.Font(path, size)
            #
            # Python 3 update
            #
            # except IOError, e:
            except IOError as e:
                raise e.__class__(&#34;%s: %s&#34; % (e, path))
            font_cache[key] = font
        return font

    @staticmethod
    def get_text(*names, **kwds):
        &#34;&#34;&#34;
        Loads the contents of a text file as a string or returns it from the cache. The file is opened in
        universal newlines mode.

        Args:
            *names:
            **kwds:

        Returns:

        &#34;&#34;&#34;
        path = ResourceUtility._resource_path(&#34;%s&#34; % DEFAULT_TEXT_DIRECTORY, names, **kwds)
        text = text_cache.get(path)
        if text is None:
            text = open(path, &#34;rU&#34;).read()
            text_cache[path] = text
        return text

    @staticmethod
    def resource_path(*names, **kwds) -&gt; str:
        &#34;&#34;&#34;
        Constructs a resource pathname from the given pathname components.

        Args:
            *names:

            **kwds:

        Returns:    The resource path

        &#34;&#34;&#34;
        return ResourceUtility._resource_path(&#34;&#34;, names, **kwds)

    @staticmethod
    def get_sound(*names, **kwds):
        &#34;&#34;&#34;
        Loads the specified sound or returns it from the cache.

        If the sound is unable to be loaded for any reason, a warning message is printed and a dummy sound object
        with no-op methods is returned. This allows an application to continue without sound in an environment
        where sound support is not available.

        Args:
            *names:  Sound file name

            **kwds:

        Returns:

        &#34;&#34;&#34;
        path = ResourceUtility._resource_path(&#34;%s&#34; % DEFAULT_SOUND_DIRECTORY, names, **kwds)

        return ResourceUtility.load_sound(path)

    @staticmethod
    def load_sound(path) -&gt; &#39;Sound&#39;:
        &#34;&#34;&#34;
        Loads a sound from the file specified by path, or returns it from the cache. Like `get_sound()`,
        returns a dummy sound object if the sound cannot be loaded.
        
        Args:
            path:  Fully qualified path

        Returns: A pygame sound object

        &#34;&#34;&#34;
        if sound_cache is None:
            return dummy_sound
        sound = sound_cache.get(path)
        if not sound:
            try:
                from pygame.mixer import Sound
            #
            # Python 3 update
            #
            # except ImportError, e:
            except ImportError as e:
                ResourceUtility.no_sound(e)
                return dummy_sound
            try:
                sound = Sound(path)
            #
            # Python 3 update
            #
            # except pygame.error, e:
            except pygame.error as e:
                ResourceUtility.missing_sound(e, path)
                return dummy_sound
            sound_cache[path] = sound

        return sound

    @staticmethod
    def no_sound(e):
        &#34;&#34;&#34;
        Clear the sound cache as a side-effect

        :param e: Exception to log
        :return:
        &#34;&#34;&#34;
        global sound_cache

        ourLogger.error(&#34;albow.resource.get_sound: %s&#34;, e)
        ourLogger.error(&#34;albow.resource.get_sound: Sound not available, continuing without it&#34;)

        sound_cache = None

    @staticmethod
    def missing_sound(e, name):
        &#34;&#34;&#34;
        Log an error message on a missing sound

        :param e: The exception
        :param name: This name of the missing sound
        :return:
        &#34;&#34;&#34;
        ourLogger.error(&#34;albow.resource.get_sound: %s: %s&#34;, name, e)

    @staticmethod
    def get_cursor(*names, **kwds):
        &#34;&#34;&#34;
        Get a cursor out of the cache,  Else load it and cache it

        :param names:
        :param kwds:
        :return:
        &#34;&#34;&#34;

        path = ResourceUtility._resource_path(&#34;%s&#34; % DEFAULT_CURSORS_DIRECTORY, names, **kwds)
        cursor = cursor_cache.get(path)
        if cursor is None:
            cursor = ResourceUtility.load_cursor(path)
            cursor_cache[path] = cursor
        return cursor

    @staticmethod
    def load_cursor(path):
        &#34;&#34;&#34;
        Loads a cursor from an image file or returns it from the cache. The cursor is returned as a tuple of
        arguments suitable for passing to the PyGame function `set_cursor()`.

        .. IMPORTANT::
            The image must be no larger than 16x16 pixels and should consist only of the colours black (0, 0, 0),
            white (255, 255, 255), blue (0, 0, 255) and cyan (0, 255, 255).  Blue and cyan are used to indicate the
            position of the hotspot, with blue if the hotspot is over a black or transparent pixel, and cyan if it is
            over a white pixel.  The hotspot defaults to the top left corner.  If the image has an alpha channel, it
            should consist of fully opaque or fully transparent pixels.

        Args:
            path:  A fully qualified path the the image file

        Returns:

        &#34;&#34;&#34;
        image = ResourceUtility._get_image(path)
        width, height = image.get_size()
        hot = (0, 0)
        data = []
        mask = []
        rowbytes = (width + 7) // 8
        #
        # Python 3 update
        #
        # xr = xrange(width)
        # yr = xrange(height)
        xr = range(width)
        yr = range(height)

        for y in yr:
            bit = 0x80
            db = mb = 0
            for x in xr:
                r, g, b, a = image.get_at((x, y))
                if a &gt;= 128:
                    mb |= bit
                    if r + g + b &lt; 383:
                        db |= bit
                if r == 0 and b == 255:
                    hot = (x, y)
                bit &gt;&gt;= 1
                if not bit:
                    data.append(db)
                    mask.append(mb)
                    db = mb = 0
                    bit = 0x80
            # if bit &lt;&gt; 0x80:
            if bit != 0x80:
                data.append(db)
                mask.append(mb)
        return (8 * rowbytes, height), hot, data, mask

    @staticmethod
    def _resource_path(default_prefix, names, prefix=&#34;&#34;) -&gt; str:

        return os.path.join(ResourceUtility.find_resource_dir(), prefix or default_prefix, *names)

    @staticmethod
    def _get_image(path, border=0, optimize=optimize_images, noalpha=False, rle=run_length_encode):
        &#34;&#34;&#34;
        Loads the specified image from the images directory or returns it from the cache.

        Args:
            path:

            border: If border is specified, a border of that number of pixels is stripped from around the
            image (making it 2 * border pixels smaller in each direction).

            optimize: If optimize is true, convert_alpha() is called on the image.

            noalpha: If noalpha is true, any alpha channel is stripped from the image.

            rle:    If rle is true, the image is run-length encoded to improve blitting speed.

        Returns:  The specified image from the images directory or returns it from the cache
        &#34;&#34;&#34;
        image = image_cache.get(path)
        if not image:
            image = pygame.image.load(path)
            if noalpha:
                image = image.convert(24)
            elif optimize:
                image = image.convert_alpha()
            if rle:
                image.set_alpha(255, RLEACCEL)
            if border:
                w, h = image.get_size()
                b = border
                d = 2 * border
                image = image.subsurface(b, b, w - d, h - d)
            image_cache[path] = image
        return image</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="albow.core.ResourceUtility.ResourceUtility.find_resource_dir"><code class="name flex">
<span>def <span class="ident">find_resource_dir</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def find_resource_dir():

    directory = sys.path[0]

    while True:
        for name in DEFAULT_RESOURCE_DIRECTORY_NAMES:
            path = os.path.join(directory, name)
            if os.path.exists(path):
                return path
        parent = os.path.dirname(directory)
        if parent == directory:
            raise SystemError(&#34;albow: Unable to find Resources directory&#34;)
        directory = parent</code></pre>
</details>
</dd>
<dt id="albow.core.ResourceUtility.ResourceUtility.get_cursor"><code class="name flex">
<span>def <span class="ident">get_cursor</span></span>(<span>*names, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a cursor out of the cache,
Else load it and cache it</p>
<p>:param names:
:param kwds:
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def get_cursor(*names, **kwds):
    &#34;&#34;&#34;
    Get a cursor out of the cache,  Else load it and cache it

    :param names:
    :param kwds:
    :return:
    &#34;&#34;&#34;

    path = ResourceUtility._resource_path(&#34;%s&#34; % DEFAULT_CURSORS_DIRECTORY, names, **kwds)
    cursor = cursor_cache.get(path)
    if cursor is None:
        cursor = ResourceUtility.load_cursor(path)
        cursor_cache[path] = cursor
    return cursor</code></pre>
</details>
</dd>
<dt id="albow.core.ResourceUtility.ResourceUtility.get_font"><code class="name flex">
<span>def <span class="ident">get_font</span></span>(<span>size, *names, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads the specified font or returns it from the cache.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong></dt>
<dd>This size font to load</dd>
</dl>
<p>*names:</p>
<dl>
<dt>**kwds:</dt>
<dt><strong><code>Returns</code></strong> :&ensp;
<code>A</code> <code>pygame</code> <code>font</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def get_font(size, *names, **kwds):
    &#34;&#34;&#34;
    Loads the specified font or returns it from the cache.

    Args:
        size:   This size font to load

        *names:

        **kwds:

    Returns:    A pygame font

    &#34;&#34;&#34;
    path = ResourceUtility._resource_path(&#34;%s&#34; % DEFAULT_FONTS_DIRECTORY, names, **kwds)
    key = (path, size)
    font = font_cache.get(key)
    if not font:
        try:
            font = pygame.font.Font(path, size)
        #
        # Python 3 update
        #
        # except IOError, e:
        except IOError as e:
            raise e.__class__(&#34;%s: %s&#34; % (e, path))
        font_cache[key] = font
    return font</code></pre>
</details>
</dd>
<dt id="albow.core.ResourceUtility.ResourceUtility.get_image"><code class="name flex">
<span>def <span class="ident">get_image</span></span>(<span>*names, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads the specified image from the images directory or returns it from the cache.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For some of the options to work correctly, you must have initialized the PyGame screen before calling get_image().</p>
</div>
<h2 id="args">Args</h2>
<p>*names:</p>
<p>**kwds:
Returns:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def get_image(*names, **kwds):
    &#34;&#34;&#34;
    Loads the specified image from the images directory or returns it from the cache.

    .. WARNING::
        For some of the options to work correctly, you must have initialized the PyGame screen before calling get_image().
    Args:
        *names:

        **kwds:

    Returns:

    &#34;&#34;&#34;
    prefix = kwds.pop(&#39;prefix&#39;, &#34;%s&#34; % DEFAULT_IMAGES_DIRECTORY)
    path = ResourceUtility._resource_path(prefix, names)
    return ResourceUtility._get_image(path, **kwds)</code></pre>
</details>
</dd>
<dt id="albow.core.ResourceUtility.ResourceUtility.get_sound"><code class="name flex">
<span>def <span class="ident">get_sound</span></span>(<span>*names, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads the specified sound or returns it from the cache.</p>
<p>If the sound is unable to be loaded for any reason, a warning message is printed and a dummy sound object
with no-op methods is returned. This allows an application to continue without sound in an environment
where sound support is not available.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*names</code></strong></dt>
<dd>Sound file name</dd>
</dl>
<p>**kwds:
Returns:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def get_sound(*names, **kwds):
    &#34;&#34;&#34;
    Loads the specified sound or returns it from the cache.

    If the sound is unable to be loaded for any reason, a warning message is printed and a dummy sound object
    with no-op methods is returned. This allows an application to continue without sound in an environment
    where sound support is not available.

    Args:
        *names:  Sound file name

        **kwds:

    Returns:

    &#34;&#34;&#34;
    path = ResourceUtility._resource_path(&#34;%s&#34; % DEFAULT_SOUND_DIRECTORY, names, **kwds)

    return ResourceUtility.load_sound(path)</code></pre>
</details>
</dd>
<dt id="albow.core.ResourceUtility.ResourceUtility.get_text"><code class="name flex">
<span>def <span class="ident">get_text</span></span>(<span>*names, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads the contents of a text file as a string or returns it from the cache. The file is opened in
universal newlines mode.</p>
<h2 id="args">Args</h2>
<p><em>names:
</em>*kwds:
Returns:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def get_text(*names, **kwds):
    &#34;&#34;&#34;
    Loads the contents of a text file as a string or returns it from the cache. The file is opened in
    universal newlines mode.

    Args:
        *names:
        **kwds:

    Returns:

    &#34;&#34;&#34;
    path = ResourceUtility._resource_path(&#34;%s&#34; % DEFAULT_TEXT_DIRECTORY, names, **kwds)
    text = text_cache.get(path)
    if text is None:
        text = open(path, &#34;rU&#34;).read()
        text_cache[path] = text
    return text</code></pre>
</details>
</dd>
<dt id="albow.core.ResourceUtility.ResourceUtility.load_cursor"><code class="name flex">
<span>def <span class="ident">load_cursor</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads a cursor from an image file or returns it from the cache. The cursor is returned as a tuple of
arguments suitable for passing to the PyGame function <code>set_cursor()</code>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The image must be no larger than 16x16 pixels and should consist only of the colours black (0, 0, 0),
white (255, 255, 255), blue (0, 0, 255) and cyan (0, 255, 255).
Blue and cyan are used to indicate the
position of the hotspot, with blue if the hotspot is over a black or transparent pixel, and cyan if it is
over a white pixel.
The hotspot defaults to the top left corner.
If the image has an alpha channel, it
should consist of fully opaque or fully transparent pixels.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>A fully qualified path the the image file</dd>
</dl>
<p>Returns:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def load_cursor(path):
    &#34;&#34;&#34;
    Loads a cursor from an image file or returns it from the cache. The cursor is returned as a tuple of
    arguments suitable for passing to the PyGame function `set_cursor()`.

    .. IMPORTANT::
        The image must be no larger than 16x16 pixels and should consist only of the colours black (0, 0, 0),
        white (255, 255, 255), blue (0, 0, 255) and cyan (0, 255, 255).  Blue and cyan are used to indicate the
        position of the hotspot, with blue if the hotspot is over a black or transparent pixel, and cyan if it is
        over a white pixel.  The hotspot defaults to the top left corner.  If the image has an alpha channel, it
        should consist of fully opaque or fully transparent pixels.

    Args:
        path:  A fully qualified path the the image file

    Returns:

    &#34;&#34;&#34;
    image = ResourceUtility._get_image(path)
    width, height = image.get_size()
    hot = (0, 0)
    data = []
    mask = []
    rowbytes = (width + 7) // 8
    #
    # Python 3 update
    #
    # xr = xrange(width)
    # yr = xrange(height)
    xr = range(width)
    yr = range(height)

    for y in yr:
        bit = 0x80
        db = mb = 0
        for x in xr:
            r, g, b, a = image.get_at((x, y))
            if a &gt;= 128:
                mb |= bit
                if r + g + b &lt; 383:
                    db |= bit
            if r == 0 and b == 255:
                hot = (x, y)
            bit &gt;&gt;= 1
            if not bit:
                data.append(db)
                mask.append(mb)
                db = mb = 0
                bit = 0x80
        # if bit &lt;&gt; 0x80:
        if bit != 0x80:
            data.append(db)
            mask.append(mb)
    return (8 * rowbytes, height), hot, data, mask</code></pre>
</details>
</dd>
<dt id="albow.core.ResourceUtility.ResourceUtility.load_sound"><code class="name flex">
<span>def <span class="ident">load_sound</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads a sound from the file specified by path, or returns it from the cache. Like <code>get_sound()</code>,
returns a dummy sound object if the sound cannot be loaded.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>Fully qualified path</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>A</code> <code>pygame</code> <code>sound</code> <code>object</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def load_sound(path) -&gt; &#39;Sound&#39;:
    &#34;&#34;&#34;
    Loads a sound from the file specified by path, or returns it from the cache. Like `get_sound()`,
    returns a dummy sound object if the sound cannot be loaded.
    
    Args:
        path:  Fully qualified path

    Returns: A pygame sound object

    &#34;&#34;&#34;
    if sound_cache is None:
        return dummy_sound
    sound = sound_cache.get(path)
    if not sound:
        try:
            from pygame.mixer import Sound
        #
        # Python 3 update
        #
        # except ImportError, e:
        except ImportError as e:
            ResourceUtility.no_sound(e)
            return dummy_sound
        try:
            sound = Sound(path)
        #
        # Python 3 update
        #
        # except pygame.error, e:
        except pygame.error as e:
            ResourceUtility.missing_sound(e, path)
            return dummy_sound
        sound_cache[path] = sound

    return sound</code></pre>
</details>
</dd>
<dt id="albow.core.ResourceUtility.ResourceUtility.missing_sound"><code class="name flex">
<span>def <span class="ident">missing_sound</span></span>(<span>e, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Log an error message on a missing sound</p>
<p>:param e: The exception
:param name: This name of the missing sound
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def missing_sound(e, name):
    &#34;&#34;&#34;
    Log an error message on a missing sound

    :param e: The exception
    :param name: This name of the missing sound
    :return:
    &#34;&#34;&#34;
    ourLogger.error(&#34;albow.resource.get_sound: %s: %s&#34;, name, e)</code></pre>
</details>
</dd>
<dt id="albow.core.ResourceUtility.ResourceUtility.no_sound"><code class="name flex">
<span>def <span class="ident">no_sound</span></span>(<span>e)</span>
</code></dt>
<dd>
<section class="desc"><p>Clear the sound cache as a side-effect</p>
<p>:param e: Exception to log
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def no_sound(e):
    &#34;&#34;&#34;
    Clear the sound cache as a side-effect

    :param e: Exception to log
    :return:
    &#34;&#34;&#34;
    global sound_cache

    ourLogger.error(&#34;albow.resource.get_sound: %s&#34;, e)
    ourLogger.error(&#34;albow.resource.get_sound: Sound not available, continuing without it&#34;)

    sound_cache = None</code></pre>
</details>
</dd>
<dt id="albow.core.ResourceUtility.ResourceUtility.resource_exists"><code class="name flex">
<span>def <span class="ident">resource_exists</span></span>(<span>*names, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns true if a resource exists with the given pathname components.</p>
<h2 id="args">Args</h2>
<p>*names:</p>
<dl>
<dt>**kwds:</dt>
<dt><strong><code>Returns</code></strong> :&ensp; <code>True</code> <code>if</code> <code>it</code> <code>does</code>, <code>else</code> <code>False</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def resource_exists(*names, **kwds) -&gt; bool:
    &#34;&#34;&#34;
    Returns true if a resource exists with the given pathname components.

    Args:
        *names:

        **kwds:

    Returns:  `True` if it does, else `False`

    &#34;&#34;&#34;
    return os.path.exists(ResourceUtility._resource_path(&#34;&#34;, names, **kwds))</code></pre>
</details>
</dd>
<dt id="albow.core.ResourceUtility.ResourceUtility.resource_path"><code class="name flex">
<span>def <span class="ident">resource_path</span></span>(<span>*names, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs a resource pathname from the given pathname components.</p>
<h2 id="args">Args</h2>
<p>*names:</p>
<dl>
<dt>**kwds:</dt>
<dt><strong><code>Returns</code></strong> :&ensp;
<code>The</code> <code>resource</code> <code>path</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def resource_path(*names, **kwds) -&gt; str:
    &#34;&#34;&#34;
    Constructs a resource pathname from the given pathname components.

    Args:
        *names:

        **kwds:

    Returns:    The resource path

    &#34;&#34;&#34;
    return ResourceUtility._resource_path(&#34;&#34;, names, **kwds)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="albow.core" href="index.html">albow.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="albow.core.ResourceUtility.optimize_images" href="#albow.core.ResourceUtility.optimize_images">optimize_images</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="albow.core.ResourceUtility.ResourceUtility" href="#albow.core.ResourceUtility.ResourceUtility">ResourceUtility</a></code></h4>
<ul class="two-column">
<li><code><a title="albow.core.ResourceUtility.ResourceUtility.find_resource_dir" href="#albow.core.ResourceUtility.ResourceUtility.find_resource_dir">find_resource_dir</a></code></li>
<li><code><a title="albow.core.ResourceUtility.ResourceUtility.get_cursor" href="#albow.core.ResourceUtility.ResourceUtility.get_cursor">get_cursor</a></code></li>
<li><code><a title="albow.core.ResourceUtility.ResourceUtility.get_font" href="#albow.core.ResourceUtility.ResourceUtility.get_font">get_font</a></code></li>
<li><code><a title="albow.core.ResourceUtility.ResourceUtility.get_image" href="#albow.core.ResourceUtility.ResourceUtility.get_image">get_image</a></code></li>
<li><code><a title="albow.core.ResourceUtility.ResourceUtility.get_sound" href="#albow.core.ResourceUtility.ResourceUtility.get_sound">get_sound</a></code></li>
<li><code><a title="albow.core.ResourceUtility.ResourceUtility.get_text" href="#albow.core.ResourceUtility.ResourceUtility.get_text">get_text</a></code></li>
<li><code><a title="albow.core.ResourceUtility.ResourceUtility.load_cursor" href="#albow.core.ResourceUtility.ResourceUtility.load_cursor">load_cursor</a></code></li>
<li><code><a title="albow.core.ResourceUtility.ResourceUtility.load_sound" href="#albow.core.ResourceUtility.ResourceUtility.load_sound">load_sound</a></code></li>
<li><code><a title="albow.core.ResourceUtility.ResourceUtility.missing_sound" href="#albow.core.ResourceUtility.ResourceUtility.missing_sound">missing_sound</a></code></li>
<li><code><a title="albow.core.ResourceUtility.ResourceUtility.no_sound" href="#albow.core.ResourceUtility.ResourceUtility.no_sound">no_sound</a></code></li>
<li><code><a title="albow.core.ResourceUtility.ResourceUtility.resource_exists" href="#albow.core.ResourceUtility.ResourceUtility.resource_exists">resource_exists</a></code></li>
<li><code><a title="albow.core.ResourceUtility.ResourceUtility.resource_path" href="#albow.core.ResourceUtility.ResourceUtility.resource_path">resource_path</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>