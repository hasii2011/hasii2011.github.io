<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.0" />
<title>albow.core.RootWidget API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>albow.core.RootWidget</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import sys
from time import sleep

from pygame.locals import *

import pygame
from pygame.mouse import set_visible as set_mouse_visible
from pygame.time import set_timer as set_pygame_timer

from pygame import Surface

from pygame.event import Event
from pygame.event import get_grab
from pygame.event import set_grab

from albow.core.Widget import Widget

from albow.core.Scheduler import Scheduler

from albow.core.CoreUtilities import CoreUtilities

from albow.core.CancelException import CancelException
from albow.core.ApplicationException import ApplicationException

from albow.media.MusicUtilities import MusicUtilities

MUSIC_END_EVENT = USEREVENT + 1

DOUBLE_CLICK_TIME = 300 # milliseconds

#
# Ignore PyCharm warning about unexpected arguments
# Fix this way:          event.dict[&#39;ray&#39;] = (p0, p1)
# dict([(&#39;sape&#39;, 4139), (&#39;guido&#39;, 4127), (&#39;jack&#39;, 4098)])
#
last_mouse_event: Event = Event(0, pos=(0, 0), local=(0, 0))
last_mouse_event_handler = None

root_widget = None     # Root of the containment hierarchy

top_widget = None      # Initial dispatch target
clicked_widget = None  # Target of mouse_drag and mouse_up events
timer_event = None     # Timer event pending delivery
next_frame_due = 0.0   #


def get_top_widget():
    return top_widget


def get_focus():
    return top_widget.get_focus()


def get_root():
    &#34;&#34;&#34;

    Returns:  The root widget.

    &#34;&#34;&#34;
    return root_widget


class RootWidget(Widget):
    &#34;&#34;&#34;
    For the GUI to function, there must be exactly one instance of RootWidget. It implements the main event loop
    and serves as the ultimate container for all other visible widgets.

    The root widget can be found using the get_root() function of the RootWidget module.

    &#34;&#34;&#34;
    #
    #  surface   Pygame display surface
    #  is_gl     True if OpenGL surface

    redraw_every_frame = False
    &#34;&#34;&#34;
    If true, all widgets will be redrawn on every animation frame (i.e. after every call to begin_frame()). If false, 
    redrawing only occurs after user input events, such as mouse clicks and keystrokes, or if a widget calls 
    its invalidate() method. The default is false.

    &#34;&#34;&#34;
    do_draw            = False
    _is_gl_container   = True
    frame_time         = 0.0
    _use_sleep         = True

    def __init__(self, surface: Surface, **kwds):
        &#34;&#34;&#34;
        Initializes the root widget with the given surface, which will normally be the PyGame screen,
        but could be a subsurface of it.

        Args:
            surface:  A pygame surface

            **kwds:
        &#34;&#34;&#34;
        global root_widget
        #
        # Python 3 update
        #
        # Widget.__init__(self, surface.get_rect())
        super().__init__(surface.get_rect(), **kwds)

        CoreUtilities.init_timebase()
        self.surface = surface
        root_widget = self
        Widget.root_widget = self
        #
        # Python 3 update
        #
        # self.is_gl = surface.get_flags() &amp; OPENGL &lt;&gt; 0
        self.is_gl = surface.get_flags() &amp; OPENGL != 0
        if self.is_gl:

            from albow.openGL.GLSurface import GLSurface
            self.gl_surface = GLSurface(surface, self.rect)

    def set_timer(self, ms):
        &#34;&#34;&#34;
        Arranges for timer events to be generated every interval milliseconds. See timer_event().

        Args:
            ms:  The timer interval in milli-seconds

        &#34;&#34;&#34;
        self.frame_time = ms
        if not self._use_sleep:
            set_pygame_timer(USEREVENT, max(1, int(round(ms))))

    def run(self):
        &#34;&#34;&#34;
        Runs the main event loop. Control is retained until a QUIT event is received, whereupon the quit() method i
        s called.

        &#34;&#34;&#34;
        self.run_modal(None)

    def run_modal(self, modal_widget: Widget):
        &#34;&#34;&#34;
            Runs a modal event loop. The widget is run as a modal dialog until its dismiss() method is called.
        Args:
            modal_widget:  The modal widget
        &#34;&#34;&#34;

        global last_mouse_event
        global last_mouse_event_handler
        global top_widget
        global clicked_widget
        global timer_event
        global next_frame_due

        is_modal = modal_widget is not None
        modal_widget = modal_widget or self
        relative_pause = False
        relative_warmup = 0

        try:
            old_top_widget = top_widget
            top_widget = modal_widget
            was_modal = modal_widget.is_modal

            modal_widget.is_modal = True
            modal_widget.modal_result = None
            if not modal_widget.focus_switch:
                modal_widget.tab_to_first()
                #
                #  mouse_widget = None
                #  if clicked_widget:
                #  clicked_widget = modal_widget
                #
            num_clicks = 0
            last_click_time = 0
            self.do_draw = True
            use_sleep = self._use_sleep
            while modal_widget.modal_result is None:
                # print &#34;RootWidget: frame_time =&#34;, self.frame_time ###
                #
                # Python 3 update
                #
                # defer_drawing = self.frame_time &lt;&gt; 0.0 and modal_widget.defer_drawing()
                defer_drawing = self.frame_time != 0.0 and modal_widget.defer_drawing()
                try:
                    if not is_modal:
                        if timer_event:
                            if not use_sleep and defer_drawing:
                                Scheduler.make_scheduled_calls()
                            CoreUtilities.add_modifiers(timer_event)
                            if last_mouse_event:
                                timer_event.dict[&#39;pos&#39;] = last_mouse_event.pos
                                timer_event.dict[&#39;local&#39;] = last_mouse_event.local
                            if last_mouse_event_handler:
                                last_mouse_event_handler.setup_cursor(timer_event)
                            self.do_draw = self.timer_event(timer_event)
                            timer_event = None
                        else:
                            if defer_drawing:
                                # print &#34;RootWidget: Clearing do_draw because of defer_drawing&#34; ###
                                self.do_draw = False
                    # print &#34;RootWidget: do_draw =&#34;, self.do_draw ###
                    if self.do_draw:
                        if self.is_gl:
                            # self.gl_clear()
                            # self.gl_draw_all(self, (0, 0))
                            # GL.glFlush()
                            gl_surface = self.gl_surface
                            gl_surface.gl_clear(self.bg_color)
                            self.gl_draw_all(gl_surface)
                            gl_surface.gl_flush()
                        else:
                            self.draw_all(self.surface)
                        self.do_draw = False
                        # tb1 = timestamp() ###
                        pygame.display.flip()
                    # tb2 = timestamp() ###
                    # print &#34;RootWidget: Flip block  %5d&#34; % (tb2 - tb1) ###
                    in_relative_mode = bool(modal_widget.relative_mode())
                    grab = in_relative_mode and not relative_pause
                    # if grab &lt;&gt; get_grab():
                    if grab != get_grab():
                        set_grab(grab)
                        set_mouse_visible(not grab)
                        relative_warmup = 3     # Ignore spurious deltas on entering relative mode
                        # tb1 = timestamp() ###
                        # print &#34;RootWidget: use_sleep =&#34;, use_sleep, &#34;defer_drawing =&#34;, defer_drawing ###
                    if use_sleep and defer_drawing:
                        #  print &#34;RootWidget: Handling timing&#34; ###
                        time_now = Scheduler.timestamp()
                        #  print &#34;RootWidget: Time is now&#34;, time_now ###
                        if next_frame_due &lt; time_now:
                            #  print &#34;RootWidget: Adjusting next frame due time to time now&#34; ###
                            next_frame_due = time_now
                            #  print &#34;RootWidget: Waiting for next frame due at&#34;, next_frame_due ###
                        while 1:
                            sleep_time = Scheduler.make_due_calls(time_now, next_frame_due)
                            if sleep_time &lt;= 0.0:
                                break
                            # print &#34;RootWidget: Sleeping for&#34;, sleep_time ###
                            sleep(sleep_time / 1000.0)
                            time_now = Scheduler.timestamp()
                        next_frame_due += self.frame_time
                        # print &#34;RootWidget: Next frame now due at&#34;, next_frame_due ###
                        #
                        # Pygame 1.9 update
                        #
                        # timer_event = Event(USEREVENT, time = time_now)
                        timer_event = Event(USEREVENT, dict=None)
                        events = []
                    else:
                        events = [pygame.event.wait()]
                    # tb2 = timestamp() ###
                    # tb = tb2 - tb1 ###
                    # if tb: ###
                    # print &#34;RootWidget: Event block %5d&#34; % tb ###
                    events.extend(pygame.event.get())
                    for event in events:
                        t = Scheduler.timestamp()
                        event.dict[&#39;time&#39;] = t
                        event.dict[&#39;local&#39;] = getattr(event, &#39;pos&#39;, (0, 0))
                        eventType = event.type
                        if eventType == QUIT:
                            self.quit()
                        elif eventType == MOUSEBUTTONDOWN:
                            # print &#34;RootWidget: MOUSEBUTTONDOWN: setting do_draw&#34; ###
                            self.do_draw = True
                            if t - last_click_time &lt;= DOUBLE_CLICK_TIME:
                                num_clicks += 1
                            else:
                                num_clicks = 1
                            last_click_time = t
                            event.dict[&#39;num_clicks&#39;] = num_clicks
                            CoreUtilities.add_modifiers(event)
                            last_mouse_event = event
                            if in_relative_mode:
                                event.dict[&#39;local&#39;] = (0, 0)
                                if relative_pause:
                                    relative_pause = False
                                else:
                                    #  modal_widget.dispatch_key(&#39;mouse_down&#39;, event)
                                    mouse_widget = modal_widget.get_focus()
                                    clicked_widget = mouse_widget
                                    last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_event(&#39;mouse_down&#39;, event)
                            else:
                                mouse_widget = self.find_widget(event.pos)
                                if not mouse_widget.is_inside(modal_widget):
                                    mouse_widget = modal_widget
                                clicked_widget = mouse_widget
                                last_mouse_event_handler = mouse_widget
                                mouse_widget.notify_attention_loss()
                                mouse_widget.handle_mouse(&#39;mouse_down&#39;, event)
                        elif eventType == MOUSEMOTION:
                            CoreUtilities.add_modifiers(event)
                            last_mouse_event = event
                            if in_relative_mode:
                                event.dict[&#39;local&#39;] = (0, 0)
                                if not relative_pause:
                                    if relative_warmup:
                                        relative_warmup -= 1
                                    else:
                                        #  modal_widget.dispatch_key(&#39;mouse_delta&#39;, event)
                                        mouse_widget = clicked_widget or modal_widget.get_focus()
                                        last_mouse_event_handler = mouse_widget
                                        mouse_widget.handle_event(&#39;mouse_delta&#39;, event)
                            else:
                                mouse_widget = self.find_widget(event.pos)   # Do this in else branch?
                                if clicked_widget:
                                    last_mouse_event_handler = mouse_widget  # Should this be clicked_widget?
                                    clicked_widget.handle_mouse(&#39;mouse_drag&#39;, event)
                                else:
                                    if not mouse_widget.is_inside(modal_widget):
                                        mouse_widget = modal_widget
                                    last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_mouse(&#39;mouse_move&#39;, event)
                        elif eventType == MOUSEBUTTONUP:
                            CoreUtilities.add_modifiers(event)
                            last_mouse_event = event
                            self.do_draw = True
                            if in_relative_mode:
                                event.dict[&#39;local&#39;] = (0, 0)
                                if not relative_pause:

                                    if clicked_widget:
                                        mouse_widget = clicked_widget
                                        clicked_widget = None
                                    else:
                                        mouse_widget = modal_widget.get_focus()
                                    last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_event(&#39;mouse_up&#39;, event)
                            else:
                                #  mouse_widget = self.find_widget(event.pos) # Not necessary?
                                if clicked_widget:
                                    last_mouse_event_handler = clicked_widget
                                    clicked_widget = None
                                    last_mouse_event_handler.handle_mouse(&#39;mouse_up&#39;, event)
                        elif eventType == KEYDOWN:
                            key = event.key
                            if key == K_ESCAPE and in_relative_mode and \
                                    event.mod &amp; KMOD_CTRL and event.mod &amp; KMOD_SHIFT:
                                relative_pause = True
                            elif relative_pause:
                                relative_pause = False
                            else:
                                CoreUtilities.set_modifier(key, True)
                                self.do_draw = True
                                self.send_key(modal_widget, &#39;key_down&#39;, event)
                                if last_mouse_event_handler:
                                    event.dict[&#39;pos&#39;] = last_mouse_event.pos
                                    event.dict[&#39;local&#39;] = last_mouse_event.local
                                    last_mouse_event_handler.setup_cursor(event)
                        elif eventType == KEYUP:
                            key = event.key
                            CoreUtilities.set_modifier(key, False)
                            self.do_draw = True
                            self.send_key(modal_widget, &#39;key_up&#39;, event)
                            if last_mouse_event_handler:
                                event.dict[&#39;pos&#39;] = last_mouse_event.pos
                                event.dict[&#39;local&#39;] = last_mouse_event.local
                                last_mouse_event_handler.setup_cursor(event)
                        elif eventType == MUSIC_END_EVENT:
                            self.music_end()
                        elif eventType == USEREVENT:
                            if defer_drawing and not use_sleep:
                                timer_event = event
                except CancelException:
                    pass
                #
                # Python 3 update
                #
                # except ApplicationError, e:
                except ApplicationException as e:
                    self.report_error(e)
        finally:
            modal_widget.is_modal = was_modal
            top_widget = old_top_widget
        clicked_widget = None

    def send_key(self, widget, name, event):
        CoreUtilities.add_modifiers(event)
        widget.dispatch_key(name, event)

    def begin_frame(self):
        &#34;&#34;&#34;Deprecated, use timer_event() instead.&#34;&#34;&#34;
        pass

    def get_root(self):
        return self

    def has_focus(self):
        return True

    def quit(self):
        &#34;&#34;&#34;
        This method is called when a QUIT event is received. The default implementation first calls
        confirm_quit(), and if it returns true, calls sys.exit(0).
        &#34;&#34;&#34;
        if self.confirm_quit():
            sys.exit(0)

    def get_mouse_for(self, widget):
        last = last_mouse_event
        event = Event(0, last.dict)
        event.dict[&#39;local&#39;] = widget.global_to_local(event.pos)
        CoreUtilities.add_modifiers(event)
        return event

    def music_end(self):
        MusicUtilities.music_end()

    # ========================================================================
    #
    #  Abstract methods follow
    #
    # ========================================================================

    def report_error(self, e):
        pass

    def confirm_quit(self) -&gt; bool:
        &#34;&#34;&#34;
        Called to give an opportunity to ask the user to confirm quitting the main event loop. If it returns
        true, sys.exit(0) is performed, otherwise nothing is done. The default implementation unconditionally
        returns true.

        Returns: True to confirm else False

        &#34;&#34;&#34;
        return True

    def defer_drawing(self) -&gt; bool:
        &#34;&#34;&#34;
        f this method returns true, pending display updates are only performed when a timer event occurs and the
        timer_event() method of the root widget returns true. Otherwise, the display is updated after every input
        event except for mouse-move events. The default implementation returns True.

        Returns: True to defer else False

        &#34;&#34;&#34;
        return True

    def timer_event(self, event):
        &#34;&#34;&#34;
        Called when a timer event occurs. See set_timer(). If it returns true, a display update is performed. T
        he default implementation returns true.

        Note:
            If multiple timer events occur during a single pass through the event loop, only the most recent
            one is passed to timer_event() and the others are discarded. Also, if other types of event occur during
            the same pass through the event loop, all the other events are processed before calling timer_event(), even
            if the timer event was not the last to occur chronologically.

        Args:
            event:

        Returns:  True

        &#34;&#34;&#34;
        self.begin_frame()
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="albow.core.RootWidget.get_focus"><code class="name flex">
<span>def <span class="ident">get_focus</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_focus():
    return top_widget.get_focus()</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.get_root"><code class="name flex">
<span>def <span class="ident">get_root</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns:
The root widget.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_root():
    &#34;&#34;&#34;

    Returns:  The root widget.

    &#34;&#34;&#34;
    return root_widget</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.get_top_widget"><code class="name flex">
<span>def <span class="ident">get_top_widget</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_top_widget():
    return top_widget</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="albow.core.RootWidget.RootWidget"><code class="flex name class">
<span>class <span class="ident">RootWidget</span></span>
<span>(</span><span>surface, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>For the GUI to function, there must be exactly one instance of RootWidget. It implements the main event loop
and serves as the ultimate container for all other visible widgets.</p>
<p>The root widget can be found using the get_root() function of the RootWidget module.</p>
<p>Initializes the root widget with the given surface, which will normally be the PyGame screen,
but could be a subsurface of it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>surface</code></strong></dt>
<dd>A pygame surface</dd>
</dl>
<p>**kwds:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class RootWidget(Widget):
    &#34;&#34;&#34;
    For the GUI to function, there must be exactly one instance of RootWidget. It implements the main event loop
    and serves as the ultimate container for all other visible widgets.

    The root widget can be found using the get_root() function of the RootWidget module.

    &#34;&#34;&#34;
    #
    #  surface   Pygame display surface
    #  is_gl     True if OpenGL surface

    redraw_every_frame = False
    &#34;&#34;&#34;
    If true, all widgets will be redrawn on every animation frame (i.e. after every call to begin_frame()). If false, 
    redrawing only occurs after user input events, such as mouse clicks and keystrokes, or if a widget calls 
    its invalidate() method. The default is false.

    &#34;&#34;&#34;
    do_draw            = False
    _is_gl_container   = True
    frame_time         = 0.0
    _use_sleep         = True

    def __init__(self, surface: Surface, **kwds):
        &#34;&#34;&#34;
        Initializes the root widget with the given surface, which will normally be the PyGame screen,
        but could be a subsurface of it.

        Args:
            surface:  A pygame surface

            **kwds:
        &#34;&#34;&#34;
        global root_widget
        #
        # Python 3 update
        #
        # Widget.__init__(self, surface.get_rect())
        super().__init__(surface.get_rect(), **kwds)

        CoreUtilities.init_timebase()
        self.surface = surface
        root_widget = self
        Widget.root_widget = self
        #
        # Python 3 update
        #
        # self.is_gl = surface.get_flags() &amp; OPENGL &lt;&gt; 0
        self.is_gl = surface.get_flags() &amp; OPENGL != 0
        if self.is_gl:

            from albow.openGL.GLSurface import GLSurface
            self.gl_surface = GLSurface(surface, self.rect)

    def set_timer(self, ms):
        &#34;&#34;&#34;
        Arranges for timer events to be generated every interval milliseconds. See timer_event().

        Args:
            ms:  The timer interval in milli-seconds

        &#34;&#34;&#34;
        self.frame_time = ms
        if not self._use_sleep:
            set_pygame_timer(USEREVENT, max(1, int(round(ms))))

    def run(self):
        &#34;&#34;&#34;
        Runs the main event loop. Control is retained until a QUIT event is received, whereupon the quit() method i
        s called.

        &#34;&#34;&#34;
        self.run_modal(None)

    def run_modal(self, modal_widget: Widget):
        &#34;&#34;&#34;
            Runs a modal event loop. The widget is run as a modal dialog until its dismiss() method is called.
        Args:
            modal_widget:  The modal widget
        &#34;&#34;&#34;

        global last_mouse_event
        global last_mouse_event_handler
        global top_widget
        global clicked_widget
        global timer_event
        global next_frame_due

        is_modal = modal_widget is not None
        modal_widget = modal_widget or self
        relative_pause = False
        relative_warmup = 0

        try:
            old_top_widget = top_widget
            top_widget = modal_widget
            was_modal = modal_widget.is_modal

            modal_widget.is_modal = True
            modal_widget.modal_result = None
            if not modal_widget.focus_switch:
                modal_widget.tab_to_first()
                #
                #  mouse_widget = None
                #  if clicked_widget:
                #  clicked_widget = modal_widget
                #
            num_clicks = 0
            last_click_time = 0
            self.do_draw = True
            use_sleep = self._use_sleep
            while modal_widget.modal_result is None:
                # print &#34;RootWidget: frame_time =&#34;, self.frame_time ###
                #
                # Python 3 update
                #
                # defer_drawing = self.frame_time &lt;&gt; 0.0 and modal_widget.defer_drawing()
                defer_drawing = self.frame_time != 0.0 and modal_widget.defer_drawing()
                try:
                    if not is_modal:
                        if timer_event:
                            if not use_sleep and defer_drawing:
                                Scheduler.make_scheduled_calls()
                            CoreUtilities.add_modifiers(timer_event)
                            if last_mouse_event:
                                timer_event.dict[&#39;pos&#39;] = last_mouse_event.pos
                                timer_event.dict[&#39;local&#39;] = last_mouse_event.local
                            if last_mouse_event_handler:
                                last_mouse_event_handler.setup_cursor(timer_event)
                            self.do_draw = self.timer_event(timer_event)
                            timer_event = None
                        else:
                            if defer_drawing:
                                # print &#34;RootWidget: Clearing do_draw because of defer_drawing&#34; ###
                                self.do_draw = False
                    # print &#34;RootWidget: do_draw =&#34;, self.do_draw ###
                    if self.do_draw:
                        if self.is_gl:
                            # self.gl_clear()
                            # self.gl_draw_all(self, (0, 0))
                            # GL.glFlush()
                            gl_surface = self.gl_surface
                            gl_surface.gl_clear(self.bg_color)
                            self.gl_draw_all(gl_surface)
                            gl_surface.gl_flush()
                        else:
                            self.draw_all(self.surface)
                        self.do_draw = False
                        # tb1 = timestamp() ###
                        pygame.display.flip()
                    # tb2 = timestamp() ###
                    # print &#34;RootWidget: Flip block  %5d&#34; % (tb2 - tb1) ###
                    in_relative_mode = bool(modal_widget.relative_mode())
                    grab = in_relative_mode and not relative_pause
                    # if grab &lt;&gt; get_grab():
                    if grab != get_grab():
                        set_grab(grab)
                        set_mouse_visible(not grab)
                        relative_warmup = 3     # Ignore spurious deltas on entering relative mode
                        # tb1 = timestamp() ###
                        # print &#34;RootWidget: use_sleep =&#34;, use_sleep, &#34;defer_drawing =&#34;, defer_drawing ###
                    if use_sleep and defer_drawing:
                        #  print &#34;RootWidget: Handling timing&#34; ###
                        time_now = Scheduler.timestamp()
                        #  print &#34;RootWidget: Time is now&#34;, time_now ###
                        if next_frame_due &lt; time_now:
                            #  print &#34;RootWidget: Adjusting next frame due time to time now&#34; ###
                            next_frame_due = time_now
                            #  print &#34;RootWidget: Waiting for next frame due at&#34;, next_frame_due ###
                        while 1:
                            sleep_time = Scheduler.make_due_calls(time_now, next_frame_due)
                            if sleep_time &lt;= 0.0:
                                break
                            # print &#34;RootWidget: Sleeping for&#34;, sleep_time ###
                            sleep(sleep_time / 1000.0)
                            time_now = Scheduler.timestamp()
                        next_frame_due += self.frame_time
                        # print &#34;RootWidget: Next frame now due at&#34;, next_frame_due ###
                        #
                        # Pygame 1.9 update
                        #
                        # timer_event = Event(USEREVENT, time = time_now)
                        timer_event = Event(USEREVENT, dict=None)
                        events = []
                    else:
                        events = [pygame.event.wait()]
                    # tb2 = timestamp() ###
                    # tb = tb2 - tb1 ###
                    # if tb: ###
                    # print &#34;RootWidget: Event block %5d&#34; % tb ###
                    events.extend(pygame.event.get())
                    for event in events:
                        t = Scheduler.timestamp()
                        event.dict[&#39;time&#39;] = t
                        event.dict[&#39;local&#39;] = getattr(event, &#39;pos&#39;, (0, 0))
                        eventType = event.type
                        if eventType == QUIT:
                            self.quit()
                        elif eventType == MOUSEBUTTONDOWN:
                            # print &#34;RootWidget: MOUSEBUTTONDOWN: setting do_draw&#34; ###
                            self.do_draw = True
                            if t - last_click_time &lt;= DOUBLE_CLICK_TIME:
                                num_clicks += 1
                            else:
                                num_clicks = 1
                            last_click_time = t
                            event.dict[&#39;num_clicks&#39;] = num_clicks
                            CoreUtilities.add_modifiers(event)
                            last_mouse_event = event
                            if in_relative_mode:
                                event.dict[&#39;local&#39;] = (0, 0)
                                if relative_pause:
                                    relative_pause = False
                                else:
                                    #  modal_widget.dispatch_key(&#39;mouse_down&#39;, event)
                                    mouse_widget = modal_widget.get_focus()
                                    clicked_widget = mouse_widget
                                    last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_event(&#39;mouse_down&#39;, event)
                            else:
                                mouse_widget = self.find_widget(event.pos)
                                if not mouse_widget.is_inside(modal_widget):
                                    mouse_widget = modal_widget
                                clicked_widget = mouse_widget
                                last_mouse_event_handler = mouse_widget
                                mouse_widget.notify_attention_loss()
                                mouse_widget.handle_mouse(&#39;mouse_down&#39;, event)
                        elif eventType == MOUSEMOTION:
                            CoreUtilities.add_modifiers(event)
                            last_mouse_event = event
                            if in_relative_mode:
                                event.dict[&#39;local&#39;] = (0, 0)
                                if not relative_pause:
                                    if relative_warmup:
                                        relative_warmup -= 1
                                    else:
                                        #  modal_widget.dispatch_key(&#39;mouse_delta&#39;, event)
                                        mouse_widget = clicked_widget or modal_widget.get_focus()
                                        last_mouse_event_handler = mouse_widget
                                        mouse_widget.handle_event(&#39;mouse_delta&#39;, event)
                            else:
                                mouse_widget = self.find_widget(event.pos)   # Do this in else branch?
                                if clicked_widget:
                                    last_mouse_event_handler = mouse_widget  # Should this be clicked_widget?
                                    clicked_widget.handle_mouse(&#39;mouse_drag&#39;, event)
                                else:
                                    if not mouse_widget.is_inside(modal_widget):
                                        mouse_widget = modal_widget
                                    last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_mouse(&#39;mouse_move&#39;, event)
                        elif eventType == MOUSEBUTTONUP:
                            CoreUtilities.add_modifiers(event)
                            last_mouse_event = event
                            self.do_draw = True
                            if in_relative_mode:
                                event.dict[&#39;local&#39;] = (0, 0)
                                if not relative_pause:

                                    if clicked_widget:
                                        mouse_widget = clicked_widget
                                        clicked_widget = None
                                    else:
                                        mouse_widget = modal_widget.get_focus()
                                    last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_event(&#39;mouse_up&#39;, event)
                            else:
                                #  mouse_widget = self.find_widget(event.pos) # Not necessary?
                                if clicked_widget:
                                    last_mouse_event_handler = clicked_widget
                                    clicked_widget = None
                                    last_mouse_event_handler.handle_mouse(&#39;mouse_up&#39;, event)
                        elif eventType == KEYDOWN:
                            key = event.key
                            if key == K_ESCAPE and in_relative_mode and \
                                    event.mod &amp; KMOD_CTRL and event.mod &amp; KMOD_SHIFT:
                                relative_pause = True
                            elif relative_pause:
                                relative_pause = False
                            else:
                                CoreUtilities.set_modifier(key, True)
                                self.do_draw = True
                                self.send_key(modal_widget, &#39;key_down&#39;, event)
                                if last_mouse_event_handler:
                                    event.dict[&#39;pos&#39;] = last_mouse_event.pos
                                    event.dict[&#39;local&#39;] = last_mouse_event.local
                                    last_mouse_event_handler.setup_cursor(event)
                        elif eventType == KEYUP:
                            key = event.key
                            CoreUtilities.set_modifier(key, False)
                            self.do_draw = True
                            self.send_key(modal_widget, &#39;key_up&#39;, event)
                            if last_mouse_event_handler:
                                event.dict[&#39;pos&#39;] = last_mouse_event.pos
                                event.dict[&#39;local&#39;] = last_mouse_event.local
                                last_mouse_event_handler.setup_cursor(event)
                        elif eventType == MUSIC_END_EVENT:
                            self.music_end()
                        elif eventType == USEREVENT:
                            if defer_drawing and not use_sleep:
                                timer_event = event
                except CancelException:
                    pass
                #
                # Python 3 update
                #
                # except ApplicationError, e:
                except ApplicationException as e:
                    self.report_error(e)
        finally:
            modal_widget.is_modal = was_modal
            top_widget = old_top_widget
        clicked_widget = None

    def send_key(self, widget, name, event):
        CoreUtilities.add_modifiers(event)
        widget.dispatch_key(name, event)

    def begin_frame(self):
        &#34;&#34;&#34;Deprecated, use timer_event() instead.&#34;&#34;&#34;
        pass

    def get_root(self):
        return self

    def has_focus(self):
        return True

    def quit(self):
        &#34;&#34;&#34;
        This method is called when a QUIT event is received. The default implementation first calls
        confirm_quit(), and if it returns true, calls sys.exit(0).
        &#34;&#34;&#34;
        if self.confirm_quit():
            sys.exit(0)

    def get_mouse_for(self, widget):
        last = last_mouse_event
        event = Event(0, last.dict)
        event.dict[&#39;local&#39;] = widget.global_to_local(event.pos)
        CoreUtilities.add_modifiers(event)
        return event

    def music_end(self):
        MusicUtilities.music_end()

    # ========================================================================
    #
    #  Abstract methods follow
    #
    # ========================================================================

    def report_error(self, e):
        pass

    def confirm_quit(self) -&gt; bool:
        &#34;&#34;&#34;
        Called to give an opportunity to ask the user to confirm quitting the main event loop. If it returns
        true, sys.exit(0) is performed, otherwise nothing is done. The default implementation unconditionally
        returns true.

        Returns: True to confirm else False

        &#34;&#34;&#34;
        return True

    def defer_drawing(self) -&gt; bool:
        &#34;&#34;&#34;
        f this method returns true, pending display updates are only performed when a timer event occurs and the
        timer_event() method of the root widget returns true. Otherwise, the display is updated after every input
        event except for mouse-move events. The default implementation returns True.

        Returns: True to defer else False

        &#34;&#34;&#34;
        return True

    def timer_event(self, event):
        &#34;&#34;&#34;
        Called when a timer event occurs. See set_timer(). If it returns true, a display update is performed. T
        he default implementation returns true.

        Note:
            If multiple timer events occur during a single pass through the event loop, only the most recent
            one is passed to timer_event() and the others are discarded. Also, if other types of event occur during
            the same pass through the event loop, all the other events are processed before calling timer_event(), even
            if the timer event was not the last to occur chronologically.

        Args:
            event:

        Returns:  True

        &#34;&#34;&#34;
        self.begin_frame()
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="albow.core.Widget.Widget" href="Widget.html#albow.core.Widget.Widget">Widget</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="albow.core.Shell.Shell" href="Shell.html#albow.core.Shell.Shell">Shell</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="albow.core.RootWidget.RootWidget.do_draw"><code class="name">var <span class="ident">do_draw</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.frame_time"><code class="name">var <span class="ident">frame_time</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="albow.core.RootWidget.RootWidget.redraw_every_frame"><code class="name">var <span class="ident">redraw_every_frame</span></code></dt>
<dd>
<section class="desc"><p>If true, all widgets will be redrawn on every animation frame (i.e. after every call to begin_frame()). If false,
redrawing only occurs after user input events, such as mouse clicks and keystrokes, or if a widget calls
its invalidate() method. The default is false.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="albow.core.RootWidget.RootWidget.begin_frame"><code class="name flex">
<span>def <span class="ident">begin_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Deprecated, use timer_event() instead.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def begin_frame(self):
    &#34;&#34;&#34;Deprecated, use timer_event() instead.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.confirm_quit"><code class="name flex">
<span>def <span class="ident">confirm_quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Called to give an opportunity to ask the user to confirm quitting the main event loop. If it returns
true, sys.exit(0) is performed, otherwise nothing is done. The default implementation unconditionally
returns true.</p>
<dl>
<dt><strong><code>Returns</code></strong> :&ensp;<code>True</code> <code>to</code> <code>confirm</code> <code>else</code> <code>False</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def confirm_quit(self) -&gt; bool:
    &#34;&#34;&#34;
    Called to give an opportunity to ask the user to confirm quitting the main event loop. If it returns
    true, sys.exit(0) is performed, otherwise nothing is done. The default implementation unconditionally
    returns true.

    Returns: True to confirm else False

    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.defer_drawing"><code class="name flex">
<span>def <span class="ident">defer_drawing</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>f this method returns true, pending display updates are only performed when a timer event occurs and the
timer_event() method of the root widget returns true. Otherwise, the display is updated after every input
event except for mouse-move events. The default implementation returns True.</p>
<dl>
<dt><strong><code>Returns</code></strong> :&ensp;<code>True</code> <code>to</code> <code>defer</code> <code>else</code> <code>False</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def defer_drawing(self) -&gt; bool:
    &#34;&#34;&#34;
    f this method returns true, pending display updates are only performed when a timer event occurs and the
    timer_event() method of the root widget returns true. Otherwise, the display is updated after every input
    event except for mouse-move events. The default implementation returns True.

    Returns: True to defer else False

    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.get_mouse_for"><code class="name flex">
<span>def <span class="ident">get_mouse_for</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_mouse_for(self, widget):
    last = last_mouse_event
    event = Event(0, last.dict)
    event.dict[&#39;local&#39;] = widget.global_to_local(event.pos)
    CoreUtilities.add_modifiers(event)
    return event</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.music_end"><code class="name flex">
<span>def <span class="ident">music_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def music_end(self):
    MusicUtilities.music_end()</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This method is called when a QUIT event is received. The default implementation first calls
confirm_quit(), and if it returns true, calls sys.exit(0).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def quit(self):
    &#34;&#34;&#34;
    This method is called when a QUIT event is received. The default implementation first calls
    confirm_quit(), and if it returns true, calls sys.exit(0).
    &#34;&#34;&#34;
    if self.confirm_quit():
        sys.exit(0)</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.report_error"><code class="name flex">
<span>def <span class="ident">report_error</span></span>(<span>self, e)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def report_error(self, e):
    pass</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Runs the main event loop. Control is retained until a QUIT event is received, whereupon the quit() method i
s called.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    Runs the main event loop. Control is retained until a QUIT event is received, whereupon the quit() method i
    s called.

    &#34;&#34;&#34;
    self.run_modal(None)</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.run_modal"><code class="name flex">
<span>def <span class="ident">run_modal</span></span>(<span>self, modal_widget)</span>
</code></dt>
<dd>
<section class="desc"><p>Runs a modal event loop. The widget is run as a modal dialog until its dismiss() method is called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>modal_widget</code></strong></dt>
<dd>The modal widget</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def run_modal(self, modal_widget: Widget):
    &#34;&#34;&#34;
        Runs a modal event loop. The widget is run as a modal dialog until its dismiss() method is called.
    Args:
        modal_widget:  The modal widget
    &#34;&#34;&#34;

    global last_mouse_event
    global last_mouse_event_handler
    global top_widget
    global clicked_widget
    global timer_event
    global next_frame_due

    is_modal = modal_widget is not None
    modal_widget = modal_widget or self
    relative_pause = False
    relative_warmup = 0

    try:
        old_top_widget = top_widget
        top_widget = modal_widget
        was_modal = modal_widget.is_modal

        modal_widget.is_modal = True
        modal_widget.modal_result = None
        if not modal_widget.focus_switch:
            modal_widget.tab_to_first()
            #
            #  mouse_widget = None
            #  if clicked_widget:
            #  clicked_widget = modal_widget
            #
        num_clicks = 0
        last_click_time = 0
        self.do_draw = True
        use_sleep = self._use_sleep
        while modal_widget.modal_result is None:
            # print &#34;RootWidget: frame_time =&#34;, self.frame_time ###
            #
            # Python 3 update
            #
            # defer_drawing = self.frame_time &lt;&gt; 0.0 and modal_widget.defer_drawing()
            defer_drawing = self.frame_time != 0.0 and modal_widget.defer_drawing()
            try:
                if not is_modal:
                    if timer_event:
                        if not use_sleep and defer_drawing:
                            Scheduler.make_scheduled_calls()
                        CoreUtilities.add_modifiers(timer_event)
                        if last_mouse_event:
                            timer_event.dict[&#39;pos&#39;] = last_mouse_event.pos
                            timer_event.dict[&#39;local&#39;] = last_mouse_event.local
                        if last_mouse_event_handler:
                            last_mouse_event_handler.setup_cursor(timer_event)
                        self.do_draw = self.timer_event(timer_event)
                        timer_event = None
                    else:
                        if defer_drawing:
                            # print &#34;RootWidget: Clearing do_draw because of defer_drawing&#34; ###
                            self.do_draw = False
                # print &#34;RootWidget: do_draw =&#34;, self.do_draw ###
                if self.do_draw:
                    if self.is_gl:
                        # self.gl_clear()
                        # self.gl_draw_all(self, (0, 0))
                        # GL.glFlush()
                        gl_surface = self.gl_surface
                        gl_surface.gl_clear(self.bg_color)
                        self.gl_draw_all(gl_surface)
                        gl_surface.gl_flush()
                    else:
                        self.draw_all(self.surface)
                    self.do_draw = False
                    # tb1 = timestamp() ###
                    pygame.display.flip()
                # tb2 = timestamp() ###
                # print &#34;RootWidget: Flip block  %5d&#34; % (tb2 - tb1) ###
                in_relative_mode = bool(modal_widget.relative_mode())
                grab = in_relative_mode and not relative_pause
                # if grab &lt;&gt; get_grab():
                if grab != get_grab():
                    set_grab(grab)
                    set_mouse_visible(not grab)
                    relative_warmup = 3     # Ignore spurious deltas on entering relative mode
                    # tb1 = timestamp() ###
                    # print &#34;RootWidget: use_sleep =&#34;, use_sleep, &#34;defer_drawing =&#34;, defer_drawing ###
                if use_sleep and defer_drawing:
                    #  print &#34;RootWidget: Handling timing&#34; ###
                    time_now = Scheduler.timestamp()
                    #  print &#34;RootWidget: Time is now&#34;, time_now ###
                    if next_frame_due &lt; time_now:
                        #  print &#34;RootWidget: Adjusting next frame due time to time now&#34; ###
                        next_frame_due = time_now
                        #  print &#34;RootWidget: Waiting for next frame due at&#34;, next_frame_due ###
                    while 1:
                        sleep_time = Scheduler.make_due_calls(time_now, next_frame_due)
                        if sleep_time &lt;= 0.0:
                            break
                        # print &#34;RootWidget: Sleeping for&#34;, sleep_time ###
                        sleep(sleep_time / 1000.0)
                        time_now = Scheduler.timestamp()
                    next_frame_due += self.frame_time
                    # print &#34;RootWidget: Next frame now due at&#34;, next_frame_due ###
                    #
                    # Pygame 1.9 update
                    #
                    # timer_event = Event(USEREVENT, time = time_now)
                    timer_event = Event(USEREVENT, dict=None)
                    events = []
                else:
                    events = [pygame.event.wait()]
                # tb2 = timestamp() ###
                # tb = tb2 - tb1 ###
                # if tb: ###
                # print &#34;RootWidget: Event block %5d&#34; % tb ###
                events.extend(pygame.event.get())
                for event in events:
                    t = Scheduler.timestamp()
                    event.dict[&#39;time&#39;] = t
                    event.dict[&#39;local&#39;] = getattr(event, &#39;pos&#39;, (0, 0))
                    eventType = event.type
                    if eventType == QUIT:
                        self.quit()
                    elif eventType == MOUSEBUTTONDOWN:
                        # print &#34;RootWidget: MOUSEBUTTONDOWN: setting do_draw&#34; ###
                        self.do_draw = True
                        if t - last_click_time &lt;= DOUBLE_CLICK_TIME:
                            num_clicks += 1
                        else:
                            num_clicks = 1
                        last_click_time = t
                        event.dict[&#39;num_clicks&#39;] = num_clicks
                        CoreUtilities.add_modifiers(event)
                        last_mouse_event = event
                        if in_relative_mode:
                            event.dict[&#39;local&#39;] = (0, 0)
                            if relative_pause:
                                relative_pause = False
                            else:
                                #  modal_widget.dispatch_key(&#39;mouse_down&#39;, event)
                                mouse_widget = modal_widget.get_focus()
                                clicked_widget = mouse_widget
                                last_mouse_event_handler = mouse_widget
                                mouse_widget.handle_event(&#39;mouse_down&#39;, event)
                        else:
                            mouse_widget = self.find_widget(event.pos)
                            if not mouse_widget.is_inside(modal_widget):
                                mouse_widget = modal_widget
                            clicked_widget = mouse_widget
                            last_mouse_event_handler = mouse_widget
                            mouse_widget.notify_attention_loss()
                            mouse_widget.handle_mouse(&#39;mouse_down&#39;, event)
                    elif eventType == MOUSEMOTION:
                        CoreUtilities.add_modifiers(event)
                        last_mouse_event = event
                        if in_relative_mode:
                            event.dict[&#39;local&#39;] = (0, 0)
                            if not relative_pause:
                                if relative_warmup:
                                    relative_warmup -= 1
                                else:
                                    #  modal_widget.dispatch_key(&#39;mouse_delta&#39;, event)
                                    mouse_widget = clicked_widget or modal_widget.get_focus()
                                    last_mouse_event_handler = mouse_widget
                                    mouse_widget.handle_event(&#39;mouse_delta&#39;, event)
                        else:
                            mouse_widget = self.find_widget(event.pos)   # Do this in else branch?
                            if clicked_widget:
                                last_mouse_event_handler = mouse_widget  # Should this be clicked_widget?
                                clicked_widget.handle_mouse(&#39;mouse_drag&#39;, event)
                            else:
                                if not mouse_widget.is_inside(modal_widget):
                                    mouse_widget = modal_widget
                                last_mouse_event_handler = mouse_widget
                                mouse_widget.handle_mouse(&#39;mouse_move&#39;, event)
                    elif eventType == MOUSEBUTTONUP:
                        CoreUtilities.add_modifiers(event)
                        last_mouse_event = event
                        self.do_draw = True
                        if in_relative_mode:
                            event.dict[&#39;local&#39;] = (0, 0)
                            if not relative_pause:

                                if clicked_widget:
                                    mouse_widget = clicked_widget
                                    clicked_widget = None
                                else:
                                    mouse_widget = modal_widget.get_focus()
                                last_mouse_event_handler = mouse_widget
                                mouse_widget.handle_event(&#39;mouse_up&#39;, event)
                        else:
                            #  mouse_widget = self.find_widget(event.pos) # Not necessary?
                            if clicked_widget:
                                last_mouse_event_handler = clicked_widget
                                clicked_widget = None
                                last_mouse_event_handler.handle_mouse(&#39;mouse_up&#39;, event)
                    elif eventType == KEYDOWN:
                        key = event.key
                        if key == K_ESCAPE and in_relative_mode and \
                                event.mod &amp; KMOD_CTRL and event.mod &amp; KMOD_SHIFT:
                            relative_pause = True
                        elif relative_pause:
                            relative_pause = False
                        else:
                            CoreUtilities.set_modifier(key, True)
                            self.do_draw = True
                            self.send_key(modal_widget, &#39;key_down&#39;, event)
                            if last_mouse_event_handler:
                                event.dict[&#39;pos&#39;] = last_mouse_event.pos
                                event.dict[&#39;local&#39;] = last_mouse_event.local
                                last_mouse_event_handler.setup_cursor(event)
                    elif eventType == KEYUP:
                        key = event.key
                        CoreUtilities.set_modifier(key, False)
                        self.do_draw = True
                        self.send_key(modal_widget, &#39;key_up&#39;, event)
                        if last_mouse_event_handler:
                            event.dict[&#39;pos&#39;] = last_mouse_event.pos
                            event.dict[&#39;local&#39;] = last_mouse_event.local
                            last_mouse_event_handler.setup_cursor(event)
                    elif eventType == MUSIC_END_EVENT:
                        self.music_end()
                    elif eventType == USEREVENT:
                        if defer_drawing and not use_sleep:
                            timer_event = event
            except CancelException:
                pass
            #
            # Python 3 update
            #
            # except ApplicationError, e:
            except ApplicationException as e:
                self.report_error(e)
    finally:
        modal_widget.is_modal = was_modal
        top_widget = old_top_widget
    clicked_widget = None</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.send_key"><code class="name flex">
<span>def <span class="ident">send_key</span></span>(<span>self, widget, name, event)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def send_key(self, widget, name, event):
    CoreUtilities.add_modifiers(event)
    widget.dispatch_key(name, event)</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.set_timer"><code class="name flex">
<span>def <span class="ident">set_timer</span></span>(<span>self, ms)</span>
</code></dt>
<dd>
<section class="desc"><p>Arranges for timer events to be generated every interval milliseconds. See timer_event().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ms</code></strong></dt>
<dd>The timer interval in milli-seconds</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_timer(self, ms):
    &#34;&#34;&#34;
    Arranges for timer events to be generated every interval milliseconds. See timer_event().

    Args:
        ms:  The timer interval in milli-seconds

    &#34;&#34;&#34;
    self.frame_time = ms
    if not self._use_sleep:
        set_pygame_timer(USEREVENT, max(1, int(round(ms))))</code></pre>
</details>
</dd>
<dt id="albow.core.RootWidget.RootWidget.timer_event"><code class="name flex">
<span>def <span class="ident">timer_event</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when a timer event occurs. See set_timer(). If it returns true, a display update is performed. T
he default implementation returns true.</p>
<h2 id="note">Note</h2>
<p>If multiple timer events occur during a single pass through the event loop, only the most recent
one is passed to timer_event() and the others are discarded. Also, if other types of event occur during
the same pass through the event loop, all the other events are processed before calling timer_event(), even
if the timer event was not the last to occur chronologically.</p>
<h2 id="args">Args</h2>
<dl>
<dt>event:</dt>
<dt><strong><code>Returns</code></strong> :&ensp; <code>True</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def timer_event(self, event):
    &#34;&#34;&#34;
    Called when a timer event occurs. See set_timer(). If it returns true, a display update is performed. T
    he default implementation returns true.

    Note:
        If multiple timer events occur during a single pass through the event loop, only the most recent
        one is passed to timer_event() and the others are discarded. Also, if other types of event occur during
        the same pass through the event loop, all the other events are processed before calling timer_event(), even
        if the timer event was not the last to occur chronologically.

    Args:
        event:

    Returns:  True

    &#34;&#34;&#34;
    self.begin_frame()
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="albow.core.Widget.Widget" href="Widget.html#albow.core.Widget.Widget">Widget</a></b></code>:
<ul class="hlist">
<li><code><a title="albow.core.Widget.Widget.add" href="Widget.html#albow.core.Widget.Widget.add">add</a></code></li>
<li><code><a title="albow.core.Widget.Widget.add_anchor" href="Widget.html#albow.core.Widget.Widget.add_anchor">add_anchor</a></code></li>
<li><code><a title="albow.core.Widget.Widget.add_centered" href="Widget.html#albow.core.Widget.Widget.add_centered">add_centered</a></code></li>
<li><code><a title="albow.core.Widget.Widget.anchor" href="Widget.html#albow.core.Widget.Widget.anchor">anchor</a></code></li>
<li><code><a title="albow.core.Widget.Widget.attention_lost" href="Widget.html#albow.core.Widget.Widget.attention_lost">attention_lost</a></code></li>
<li><code><a title="albow.core.Widget.Widget.augment_mouse_event" href="Widget.html#albow.core.Widget.Widget.augment_mouse_event">augment_mouse_event</a></code></li>
<li><code><a title="albow.core.Widget.Widget.bg_color" href="Widget.html#albow.core.Widget.Widget.bg_color">bg_color</a></code></li>
<li><code><a title="albow.core.Widget.Widget.bg_image" href="Widget.html#albow.core.Widget.Widget.bg_image">bg_image</a></code></li>
<li><code><a title="albow.core.Widget.Widget.border_color" href="Widget.html#albow.core.Widget.Widget.border_color">border_color</a></code></li>
<li><code><a title="albow.core.Widget.Widget.border_width" href="Widget.html#albow.core.Widget.Widget.border_width">border_width</a></code></li>
<li><code><a title="albow.core.Widget.Widget.call_handler" href="Widget.html#albow.core.Widget.Widget.call_handler">call_handler</a></code></li>
<li><code><a title="albow.core.Widget.Widget.call_parent_handler" href="Widget.html#albow.core.Widget.Widget.call_parent_handler">call_parent_handler</a></code></li>
<li><code><a title="albow.core.Widget.Widget.dismiss" href="Widget.html#albow.core.Widget.Widget.dismiss">dismiss</a></code></li>
<li><code><a title="albow.core.Widget.Widget.draw" href="Widget.html#albow.core.Widget.Widget.draw">draw</a></code></li>
<li><code><a title="albow.core.Widget.Widget.draw_over" href="Widget.html#albow.core.Widget.Widget.draw_over">draw_over</a></code></li>
<li><code><a title="albow.core.Widget.Widget.fg_color" href="Widget.html#albow.core.Widget.Widget.fg_color">fg_color</a></code></li>
<li><code><a title="albow.core.Widget.Widget.focus" href="Widget.html#albow.core.Widget.Widget.focus">focus</a></code></li>
<li><code><a title="albow.core.Widget.Widget.focus_switch" href="Widget.html#albow.core.Widget.Widget.focus_switch">focus_switch</a></code></li>
<li><code><a title="albow.core.Widget.Widget.font" href="Widget.html#albow.core.Widget.Widget.font">font</a></code></li>
<li><code><a title="albow.core.Widget.Widget.get_cursor" href="Widget.html#albow.core.Widget.Widget.get_cursor">get_cursor</a></code></li>
<li><code><a title="albow.core.Widget.Widget.get_focus" href="Widget.html#albow.core.Widget.Widget.get_focus">get_focus</a></code></li>
<li><code><a title="albow.core.Widget.Widget.get_margin_rect" href="Widget.html#albow.core.Widget.Widget.get_margin_rect">get_margin_rect</a></code></li>
<li><code><a title="albow.core.Widget.Widget.get_root" href="Widget.html#albow.core.Widget.Widget.get_root">get_root</a></code></li>
<li><code><a title="albow.core.Widget.Widget.get_top_widget" href="Widget.html#albow.core.Widget.Widget.get_top_widget">get_top_widget</a></code></li>
<li><code><a title="albow.core.Widget.Widget.get_visible" href="Widget.html#albow.core.Widget.Widget.get_visible">get_visible</a></code></li>
<li><code><a title="albow.core.Widget.Widget.global_to_local" href="Widget.html#albow.core.Widget.Widget.global_to_local">global_to_local</a></code></li>
<li><code><a title="albow.core.Widget.Widget.has_focus" href="Widget.html#albow.core.Widget.Widget.has_focus">has_focus</a></code></li>
<li><code><a title="albow.core.Widget.Widget.inherited" href="Widget.html#albow.core.Widget.Widget.inherited">inherited</a></code></li>
<li><code><a title="albow.core.Widget.Widget.invalidate" href="Widget.html#albow.core.Widget.Widget.invalidate">invalidate</a></code></li>
<li><code><a title="albow.core.Widget.Widget.is_gl_container" href="Widget.html#albow.core.Widget.Widget.is_gl_container">is_gl_container</a></code></li>
<li><code><a title="albow.core.Widget.Widget.key_down" href="Widget.html#albow.core.Widget.Widget.key_down">key_down</a></code></li>
<li><code><a title="albow.core.Widget.Widget.key_up" href="Widget.html#albow.core.Widget.Widget.key_up">key_up</a></code></li>
<li><code><a title="albow.core.Widget.Widget.local_to_global" href="Widget.html#albow.core.Widget.Widget.local_to_global">local_to_global</a></code></li>
<li><code><a title="albow.core.Widget.Widget.margin" href="Widget.html#albow.core.Widget.Widget.margin">margin</a></code></li>
<li><code><a title="albow.core.Widget.Widget.menu_bar" href="Widget.html#albow.core.Widget.Widget.menu_bar">menu_bar</a></code></li>
<li><code><a title="albow.core.Widget.Widget.parent" href="Widget.html#albow.core.Widget.Widget.parent">parent</a></code></li>
<li><code><a title="albow.core.Widget.Widget.parent_resized" href="Widget.html#albow.core.Widget.Widget.parent_resized">parent_resized</a></code></li>
<li><code><a title="albow.core.Widget.Widget.present" href="Widget.html#albow.core.Widget.Widget.present">present</a></code></li>
<li><code><a title="albow.core.Widget.Widget.rect" href="Widget.html#albow.core.Widget.Widget.rect">rect</a></code></li>
<li><code><a title="albow.core.Widget.Widget.relative_mode" href="Widget.html#albow.core.Widget.Widget.relative_mode">relative_mode</a></code></li>
<li><code><a title="albow.core.Widget.Widget.remove" href="Widget.html#albow.core.Widget.Widget.remove">remove</a></code></li>
<li><code><a title="albow.core.Widget.Widget.remove_anchor" href="Widget.html#albow.core.Widget.Widget.remove_anchor">remove_anchor</a></code></li>
<li><code><a title="albow.core.Widget.Widget.resized" href="Widget.html#albow.core.Widget.Widget.resized">resized</a></code></li>
<li><code><a title="albow.core.Widget.Widget.scale_bg" href="Widget.html#albow.core.Widget.Widget.scale_bg">scale_bg</a></code></li>
<li><code><a title="albow.core.Widget.Widget.sel_color" href="Widget.html#albow.core.Widget.Widget.sel_color">sel_color</a></code></li>
<li><code><a title="albow.core.Widget.Widget.set_parent" href="Widget.html#albow.core.Widget.Widget.set_parent">set_parent</a></code></li>
<li><code><a title="albow.core.Widget.Widget.set_size_for_text" href="Widget.html#albow.core.Widget.Widget.set_size_for_text">set_size_for_text</a></code></li>
<li><code><a title="albow.core.Widget.Widget.tab_stop" href="Widget.html#albow.core.Widget.Widget.tab_stop">tab_stop</a></code></li>
<li><code><a title="albow.core.Widget.Widget.visible" href="Widget.html#albow.core.Widget.Widget.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="albow.core" href="index.html">albow.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="albow.core.RootWidget.get_focus" href="#albow.core.RootWidget.get_focus">get_focus</a></code></li>
<li><code><a title="albow.core.RootWidget.get_root" href="#albow.core.RootWidget.get_root">get_root</a></code></li>
<li><code><a title="albow.core.RootWidget.get_top_widget" href="#albow.core.RootWidget.get_top_widget">get_top_widget</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="albow.core.RootWidget.RootWidget" href="#albow.core.RootWidget.RootWidget">RootWidget</a></code></h4>
<ul class="two-column">
<li><code><a title="albow.core.RootWidget.RootWidget.begin_frame" href="#albow.core.RootWidget.RootWidget.begin_frame">begin_frame</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.confirm_quit" href="#albow.core.RootWidget.RootWidget.confirm_quit">confirm_quit</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.defer_drawing" href="#albow.core.RootWidget.RootWidget.defer_drawing">defer_drawing</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.do_draw" href="#albow.core.RootWidget.RootWidget.do_draw">do_draw</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.frame_time" href="#albow.core.RootWidget.RootWidget.frame_time">frame_time</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.get_mouse_for" href="#albow.core.RootWidget.RootWidget.get_mouse_for">get_mouse_for</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.music_end" href="#albow.core.RootWidget.RootWidget.music_end">music_end</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.quit" href="#albow.core.RootWidget.RootWidget.quit">quit</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.redraw_every_frame" href="#albow.core.RootWidget.RootWidget.redraw_every_frame">redraw_every_frame</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.report_error" href="#albow.core.RootWidget.RootWidget.report_error">report_error</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.run" href="#albow.core.RootWidget.RootWidget.run">run</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.run_modal" href="#albow.core.RootWidget.RootWidget.run_modal">run_modal</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.send_key" href="#albow.core.RootWidget.RootWidget.send_key">send_key</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.set_timer" href="#albow.core.RootWidget.RootWidget.set_timer">set_timer</a></code></li>
<li><code><a title="albow.core.RootWidget.RootWidget.timer_event" href="#albow.core.RootWidget.RootWidget.timer_event">timer_event</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>